"use strict";
var Ia = Object.create;
var qe = Object.defineProperty;
var Sa = Object.getOwnPropertyDescriptor;
var Ea = Object.getOwnPropertyNames;
var Ca = Object.getPrototypeOf, Pa = Object.prototype.hasOwnProperty;
var i = (t, e) => qe(t, "name", { value: e, configurable: !0 });
var jn = (t, e) => () => (t && (e = t(t = 0)), e);
var S = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports), Aa = (t, e) => {
  for (var r in e)
    qe(t, r, { get: e[r], enumerable: !0 });
}, Rn = (t, e, r, n) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let s of Ea(e))
      !Pa.call(t, s) && s !== r && qe(t, s, { get: () => e[s], enumerable: !(n = Sa(e, s)) || n.enumerable });
  return t;
};
var T = (t, e, r) => (r = t != null ? Ia(Ca(t)) : {}, Rn(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  e || !t || !t.__esModule ? qe(r, "default", { value: t, enumerable: !0 }) : r,
  t
)), Oa = (t) => Rn(qe({}, "__esModule", { value: !0 }), t);

// ../node_modules/picocolors/picocolors.js
var Mn = S((Ol, fr) => {
  var bt = process || {}, Nn = bt.argv || [], xt = bt.env || {}, ja = !(xt.NO_COLOR || Nn.includes("--no-color")) && (!!xt.FORCE_COLOR || Nn.
  includes("--color") || bt.platform === "win32" || (bt.stdout || {}).isTTY && xt.TERM !== "dumb" || !!xt.CI), Ra = /* @__PURE__ */ i((t, e, r = t) => (n) => {
    let s = "" + n, o = s.indexOf(e, t.length);
    return ~o ? t + Na(s, e, r, o) + e : t + s + e;
  }, "formatter"), Na = /* @__PURE__ */ i((t, e, r, n) => {
    let s = "", o = 0;
    do
      s += t.substring(o, n) + r, o = n + e.length, n = t.indexOf(e, o);
    while (~n);
    return s + t.substring(o);
  }, "replaceClose"), Zn = /* @__PURE__ */ i((t = ja) => {
    let e = t ? Ra : () => String;
    return {
      isColorSupported: t,
      reset: e("\x1B[0m", "\x1B[0m"),
      bold: e("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
      dim: e("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
      italic: e("\x1B[3m", "\x1B[23m"),
      underline: e("\x1B[4m", "\x1B[24m"),
      inverse: e("\x1B[7m", "\x1B[27m"),
      hidden: e("\x1B[8m", "\x1B[28m"),
      strikethrough: e("\x1B[9m", "\x1B[29m"),
      black: e("\x1B[30m", "\x1B[39m"),
      red: e("\x1B[31m", "\x1B[39m"),
      green: e("\x1B[32m", "\x1B[39m"),
      yellow: e("\x1B[33m", "\x1B[39m"),
      blue: e("\x1B[34m", "\x1B[39m"),
      magenta: e("\x1B[35m", "\x1B[39m"),
      cyan: e("\x1B[36m", "\x1B[39m"),
      white: e("\x1B[37m", "\x1B[39m"),
      gray: e("\x1B[90m", "\x1B[39m"),
      bgBlack: e("\x1B[40m", "\x1B[49m"),
      bgRed: e("\x1B[41m", "\x1B[49m"),
      bgGreen: e("\x1B[42m", "\x1B[49m"),
      bgYellow: e("\x1B[43m", "\x1B[49m"),
      bgBlue: e("\x1B[44m", "\x1B[49m"),
      bgMagenta: e("\x1B[45m", "\x1B[49m"),
      bgCyan: e("\x1B[46m", "\x1B[49m"),
      bgWhite: e("\x1B[47m", "\x1B[49m"),
      blackBright: e("\x1B[90m", "\x1B[39m"),
      redBright: e("\x1B[91m", "\x1B[39m"),
      greenBright: e("\x1B[92m", "\x1B[39m"),
      yellowBright: e("\x1B[93m", "\x1B[39m"),
      blueBright: e("\x1B[94m", "\x1B[39m"),
      magentaBright: e("\x1B[95m", "\x1B[39m"),
      cyanBright: e("\x1B[96m", "\x1B[39m"),
      whiteBright: e("\x1B[97m", "\x1B[39m"),
      bgBlackBright: e("\x1B[100m", "\x1B[49m"),
      bgRedBright: e("\x1B[101m", "\x1B[49m"),
      bgGreenBright: e("\x1B[102m", "\x1B[49m"),
      bgYellowBright: e("\x1B[103m", "\x1B[49m"),
      bgBlueBright: e("\x1B[104m", "\x1B[49m"),
      bgMagentaBright: e("\x1B[105m", "\x1B[49m"),
      bgCyanBright: e("\x1B[106m", "\x1B[49m"),
      bgWhiteBright: e("\x1B[107m", "\x1B[49m")
    };
  }, "createColors");
  fr.exports = Zn();
  fr.exports.createColors = Zn;
});

// ../node_modules/walk-up-path/dist/cjs/index.js
var Fn = S((vt) => {
  "use strict";
  Object.defineProperty(vt, "__esModule", { value: !0 });
  vt.walkUp = void 0;
  var Vn = require("path"), Za = /* @__PURE__ */ i(function* (t) {
    for (t = (0, Vn.resolve)(t); t; ) {
      yield t;
      let e = (0, Vn.dirname)(t);
      if (e === t)
        break;
      t = e;
    }
  }, "walkUp");
  vt.walkUp = Za;
});

// ../node_modules/zod/lib/helpers/util.js
var Ke = S((C) => {
  "use strict";
  Object.defineProperty(C, "__esModule", { value: !0 });
  C.getParsedType = C.ZodParsedType = C.objectUtil = C.util = void 0;
  var xr;
  (function(t) {
    t.assertEqual = (s) => s;
    function e(s) {
    }
    i(e, "assertIs"), t.assertIs = e;
    function r(s) {
      throw new Error();
    }
    i(r, "assertNever"), t.assertNever = r, t.arrayToEnum = (s) => {
      let o = {};
      for (let a of s)
        o[a] = a;
      return o;
    }, t.getValidEnumValues = (s) => {
      let o = t.objectKeys(s).filter((c) => typeof s[s[c]] != "number"), a = {};
      for (let c of o)
        a[c] = s[c];
      return t.objectValues(a);
    }, t.objectValues = (s) => t.objectKeys(s).map(function(o) {
      return s[o];
    }), t.objectKeys = typeof Object.keys == "function" ? (s) => Object.keys(s) : (s) => {
      let o = [];
      for (let a in s)
        Object.prototype.hasOwnProperty.call(s, a) && o.push(a);
      return o;
    }, t.find = (s, o) => {
      for (let a of s)
        if (o(a))
          return a;
    }, t.isInteger = typeof Number.isInteger == "function" ? (s) => Number.isInteger(s) : (s) => typeof s == "number" && isFinite(s) && Math.
    floor(s) === s;
    function n(s, o = " | ") {
      return s.map((a) => typeof a == "string" ? `'${a}'` : a).join(o);
    }
    i(n, "joinValues"), t.joinValues = n, t.jsonStringifyReplacer = (s, o) => typeof o == "bigint" ? o.toString() : o;
  })(xr || (C.util = xr = {}));
  var Kn;
  (function(t) {
    t.mergeShapes = (e, r) => ({
      ...e,
      ...r
      // second overwrites first
    });
  })(Kn || (C.objectUtil = Kn = {}));
  C.ZodParsedType = xr.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
  var Da = /* @__PURE__ */ i((t) => {
    switch (typeof t) {
      case "undefined":
        return C.ZodParsedType.undefined;
      case "string":
        return C.ZodParsedType.string;
      case "number":
        return isNaN(t) ? C.ZodParsedType.nan : C.ZodParsedType.number;
      case "boolean":
        return C.ZodParsedType.boolean;
      case "function":
        return C.ZodParsedType.function;
      case "bigint":
        return C.ZodParsedType.bigint;
      case "symbol":
        return C.ZodParsedType.symbol;
      case "object":
        return Array.isArray(t) ? C.ZodParsedType.array : t === null ? C.ZodParsedType.null : t.then && typeof t.then == "function" && t.catch &&
        typeof t.catch == "function" ? C.ZodParsedType.promise : typeof Map < "u" && t instanceof Map ? C.ZodParsedType.map : typeof Set < "\
u" && t instanceof Set ? C.ZodParsedType.set : typeof Date < "u" && t instanceof Date ? C.ZodParsedType.date : C.ZodParsedType.object;
      default:
        return C.ZodParsedType.unknown;
    }
  }, "getParsedType");
  C.getParsedType = Da;
});

// ../node_modules/zod/lib/ZodError.js
var kt = S((X) => {
  "use strict";
  Object.defineProperty(X, "__esModule", { value: !0 });
  X.ZodError = X.quotelessJson = X.ZodIssueCode = void 0;
  var zn = Ke();
  X.ZodIssueCode = zn.util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
  ]);
  var Ua = /* @__PURE__ */ i((t) => JSON.stringify(t, null, 2).replace(/"([^"]+)":/g, "$1:"), "quotelessJson");
  X.quotelessJson = Ua;
  var ze = class t extends Error {
    static {
      i(this, "ZodError");
    }
    get errors() {
      return this.issues;
    }
    constructor(e) {
      super(), this.issues = [], this.addIssue = (n) => {
        this.issues = [...this.issues, n];
      }, this.addIssues = (n = []) => {
        this.issues = [...this.issues, ...n];
      };
      let r = new.target.prototype;
      Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = "ZodError", this.issues = e;
    }
    format(e) {
      let r = e || function(o) {
        return o.message;
      }, n = { _errors: [] }, s = /* @__PURE__ */ i((o) => {
        for (let a of o.issues)
          if (a.code === "invalid_union")
            a.unionErrors.map(s);
          else if (a.code === "invalid_return_type")
            s(a.returnTypeError);
          else if (a.code === "invalid_arguments")
            s(a.argumentsError);
          else if (a.path.length === 0)
            n._errors.push(r(a));
          else {
            let c = n, p = 0;
            for (; p < a.path.length; ) {
              let l = a.path[p];
              p === a.path.length - 1 ? (c[l] = c[l] || { _errors: [] }, c[l]._errors.push(r(a))) : c[l] = c[l] || { _errors: [] }, c = c[l],
              p++;
            }
          }
      }, "processError");
      return s(this), n;
    }
    static assert(e) {
      if (!(e instanceof t))
        throw new Error(`Not a ZodError: ${e}`);
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, zn.util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(e = (r) => r.message) {
      let r = {}, n = [];
      for (let s of this.issues)
        s.path.length > 0 ? (r[s.path[0]] = r[s.path[0]] || [], r[s.path[0]].push(e(s))) : n.push(e(s));
      return { formErrors: n, fieldErrors: r };
    }
    get formErrors() {
      return this.flatten();
    }
  };
  X.ZodError = ze;
  ze.create = (t) => new ze(t);
});

// ../node_modules/zod/lib/locales/en.js
var vr = S((br) => {
  "use strict";
  Object.defineProperty(br, "__esModule", { value: !0 });
  var ie = Ke(), j = kt(), $a = /* @__PURE__ */ i((t, e) => {
    let r;
    switch (t.code) {
      case j.ZodIssueCode.invalid_type:
        t.received === ie.ZodParsedType.undefined ? r = "Required" : r = `Expected ${t.expected}, received ${t.received}`;
        break;
      case j.ZodIssueCode.invalid_literal:
        r = `Invalid literal value, expected ${JSON.stringify(t.expected, ie.util.jsonStringifyReplacer)}`;
        break;
      case j.ZodIssueCode.unrecognized_keys:
        r = `Unrecognized key(s) in object: ${ie.util.joinValues(t.keys, ", ")}`;
        break;
      case j.ZodIssueCode.invalid_union:
        r = "Invalid input";
        break;
      case j.ZodIssueCode.invalid_union_discriminator:
        r = `Invalid discriminator value. Expected ${ie.util.joinValues(t.options)}`;
        break;
      case j.ZodIssueCode.invalid_enum_value:
        r = `Invalid enum value. Expected ${ie.util.joinValues(t.options)}, received '${t.received}'`;
        break;
      case j.ZodIssueCode.invalid_arguments:
        r = "Invalid function arguments";
        break;
      case j.ZodIssueCode.invalid_return_type:
        r = "Invalid function return type";
        break;
      case j.ZodIssueCode.invalid_date:
        r = "Invalid date";
        break;
      case j.ZodIssueCode.invalid_string:
        typeof t.validation == "object" ? "includes" in t.validation ? (r = `Invalid input: must include "${t.validation.includes}"`, typeof t.
        validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${t.validation.position}`)) : "start\
sWith" in t.validation ? r = `Invalid input: must start with "${t.validation.startsWith}"` : "endsWith" in t.validation ? r = `Invalid input\
: must end with "${t.validation.endsWith}"` : ie.util.assertNever(t.validation) : t.validation !== "regex" ? r = `Invalid ${t.validation}` :
        r = "Invalid";
        break;
      case j.ZodIssueCode.too_small:
        t.type === "array" ? r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "more than"} ${t.minimum} element(s)` :
        t.type === "string" ? r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "over"} ${t.minimum} character(s)` :
        t.type === "number" ? r = `Number must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater tha\
n "}${t.minimum}` : t.type === "date" ? r = `Date must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "gre\
ater than "}${new Date(Number(t.minimum))}` : r = "Invalid input";
        break;
      case j.ZodIssueCode.too_big:
        t.type === "array" ? r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "less than"} ${t.maximum} element(s)` :
        t.type === "string" ? r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "under"} ${t.maximum} character(s)` :
        t.type === "number" ? r = `Number must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` :
        t.type === "bigint" ? r = `BigInt must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` :
        t.type === "date" ? r = `Date must be ${t.exact ? "exactly" : t.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(
        Number(t.maximum))}` : r = "Invalid input";
        break;
      case j.ZodIssueCode.custom:
        r = "Invalid input";
        break;
      case j.ZodIssueCode.invalid_intersection_types:
        r = "Intersection results could not be merged";
        break;
      case j.ZodIssueCode.not_multiple_of:
        r = `Number must be a multiple of ${t.multipleOf}`;
        break;
      case j.ZodIssueCode.not_finite:
        r = "Number must be finite";
        break;
      default:
        r = e.defaultError, ie.util.assertNever(t);
    }
    return { message: r };
  }, "errorMap");
  br.default = $a;
});

// ../node_modules/zod/lib/errors.js
var Tt = S((q) => {
  "use strict";
  var Va = q && q.__importDefault || function(t) {
    return t && t.__esModule ? t : { default: t };
  };
  Object.defineProperty(q, "__esModule", { value: !0 });
  q.getErrorMap = q.setErrorMap = q.defaultErrorMap = void 0;
  var Jn = Va(vr());
  q.defaultErrorMap = Jn.default;
  var Yn = Jn.default;
  function Fa(t) {
    Yn = t;
  }
  i(Fa, "setErrorMap");
  q.setErrorMap = Fa;
  function Ba() {
    return Yn;
  }
  i(Ba, "getErrorMap");
  q.getErrorMap = Ba;
});

// ../node_modules/zod/lib/helpers/parseUtil.js
var wr = S((I) => {
  "use strict";
  var Wa = I && I.__importDefault || function(t) {
    return t && t.__esModule ? t : { default: t };
  };
  Object.defineProperty(I, "__esModule", { value: !0 });
  I.isAsync = I.isValid = I.isDirty = I.isAborted = I.OK = I.DIRTY = I.INVALID = I.ParseStatus = I.addIssueToContext = I.EMPTY_PATH = I.makeIssue =
  void 0;
  var qa = Tt(), Hn = Wa(vr()), Ga = /* @__PURE__ */ i((t) => {
    let { data: e, path: r, errorMaps: n, issueData: s } = t, o = [...r, ...s.path || []], a = {
      ...s,
      path: o
    };
    if (s.message !== void 0)
      return {
        ...s,
        path: o,
        message: s.message
      };
    let c = "", p = n.filter((l) => !!l).slice().reverse();
    for (let l of p)
      c = l(a, { data: e, defaultError: c }).message;
    return {
      ...s,
      path: o,
      message: c
    };
  }, "makeIssue");
  I.makeIssue = Ga;
  I.EMPTY_PATH = [];
  function Ka(t, e) {
    let r = (0, qa.getErrorMap)(), n = (0, I.makeIssue)({
      issueData: e,
      data: t.data,
      path: t.path,
      errorMaps: [
        t.common.contextualErrorMap,
        // contextual error map is first priority
        t.schemaErrorMap,
        // then schema-bound map if available
        r,
        // then global override map
        r === Hn.default ? void 0 : Hn.default
        // then global default map
      ].filter((s) => !!s)
    });
    t.common.issues.push(n);
  }
  i(Ka, "addIssueToContext");
  I.addIssueToContext = Ka;
  var _r = class t {
    static {
      i(this, "ParseStatus");
    }
    constructor() {
      this.value = "valid";
    }
    dirty() {
      this.value === "valid" && (this.value = "dirty");
    }
    abort() {
      this.value !== "aborted" && (this.value = "aborted");
    }
    static mergeArray(e, r) {
      let n = [];
      for (let s of r) {
        if (s.status === "aborted")
          return I.INVALID;
        s.status === "dirty" && e.dirty(), n.push(s.value);
      }
      return { status: e.value, value: n };
    }
    static async mergeObjectAsync(e, r) {
      let n = [];
      for (let s of r) {
        let o = await s.key, a = await s.value;
        n.push({
          key: o,
          value: a
        });
      }
      return t.mergeObjectSync(e, n);
    }
    static mergeObjectSync(e, r) {
      let n = {};
      for (let s of r) {
        let { key: o, value: a } = s;
        if (o.status === "aborted" || a.status === "aborted")
          return I.INVALID;
        o.status === "dirty" && e.dirty(), a.status === "dirty" && e.dirty(), o.value !== "__proto__" && (typeof a.value < "u" || s.alwaysSet) &&
        (n[o.value] = a.value);
      }
      return { status: e.value, value: n };
    }
  };
  I.ParseStatus = _r;
  I.INVALID = Object.freeze({
    status: "aborted"
  });
  var za = /* @__PURE__ */ i((t) => ({ status: "dirty", value: t }), "DIRTY");
  I.DIRTY = za;
  var Ja = /* @__PURE__ */ i((t) => ({ status: "valid", value: t }), "OK");
  I.OK = Ja;
  var Ya = /* @__PURE__ */ i((t) => t.status === "aborted", "isAborted");
  I.isAborted = Ya;
  var Ha = /* @__PURE__ */ i((t) => t.status === "dirty", "isDirty");
  I.isDirty = Ha;
  var Xa = /* @__PURE__ */ i((t) => t.status === "valid", "isValid");
  I.isValid = Xa;
  var Qa = /* @__PURE__ */ i((t) => typeof Promise < "u" && t instanceof Promise, "isAsync");
  I.isAsync = Qa;
});

// ../node_modules/zod/lib/helpers/typeAliases.js
var Qn = S((Xn) => {
  "use strict";
  Object.defineProperty(Xn, "__esModule", { value: !0 });
});

// ../node_modules/zod/lib/helpers/errorUtil.js
var ts = S((It) => {
  "use strict";
  Object.defineProperty(It, "__esModule", { value: !0 });
  It.errorUtil = void 0;
  var es;
  (function(t) {
    t.errToObj = (e) => typeof e == "string" ? { message: e } : e || {}, t.toString = (e) => typeof e == "string" ? e : e?.message;
  })(es || (It.errorUtil = es = {}));
});

// ../node_modules/zod/lib/types.js
var ms = S((d) => {
  "use strict";
  var Et = d && d.__classPrivateFieldGet || function(t, e, r, n) {
    if (r === "a" && !n) throw new TypeError("Private accessor was defined without a getter");
    if (typeof e == "function" ? t !== e || !n : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did n\
ot declare it");
    return r === "m" ? n : r === "a" ? n.call(t) : n ? n.value : e.get(t);
  }, ss = d && d.__classPrivateFieldSet || function(t, e, r, n, s) {
    if (n === "m") throw new TypeError("Private method is not writable");
    if (n === "a" && !s) throw new TypeError("Private accessor was defined without a setter");
    if (typeof e == "function" ? t !== e || !s : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did no\
t declare it");
    return n === "a" ? s.call(t, r) : s ? s.value = r : e.set(t, r), r;
  }, Je, Ye;
  Object.defineProperty(d, "__esModule", { value: !0 });
  d.boolean = d.bigint = d.array = d.any = d.coerce = d.ZodFirstPartyTypeKind = d.late = d.ZodSchema = d.Schema = d.custom = d.ZodReadonly =
  d.ZodPipeline = d.ZodBranded = d.BRAND = d.ZodNaN = d.ZodCatch = d.ZodDefault = d.ZodNullable = d.ZodOptional = d.ZodTransformer = d.ZodEffects =
  d.ZodPromise = d.ZodNativeEnum = d.ZodEnum = d.ZodLiteral = d.ZodLazy = d.ZodFunction = d.ZodSet = d.ZodMap = d.ZodRecord = d.ZodTuple = d.
  ZodIntersection = d.ZodDiscriminatedUnion = d.ZodUnion = d.ZodObject = d.ZodArray = d.ZodVoid = d.ZodNever = d.ZodUnknown = d.ZodAny = d.ZodNull =
  d.ZodUndefined = d.ZodSymbol = d.ZodDate = d.ZodBoolean = d.ZodBigInt = d.ZodNumber = d.ZodString = d.datetimeRegex = d.ZodType = void 0;
  d.NEVER = d.void = d.unknown = d.union = d.undefined = d.tuple = d.transformer = d.symbol = d.string = d.strictObject = d.set = d.record =
  d.promise = d.preprocess = d.pipeline = d.ostring = d.optional = d.onumber = d.oboolean = d.object = d.number = d.nullable = d.null = d.never =
  d.nativeEnum = d.nan = d.map = d.literal = d.lazy = d.intersection = d.instanceof = d.function = d.enum = d.effect = d.discriminatedUnion =
  d.date = void 0;
  var St = Tt(), y = ts(), u = wr(), h = Ke(), m = kt(), D = class {
    static {
      i(this, "ParseInputLazyPath");
    }
    constructor(e, r, n, s) {
      this._cachedPath = [], this.parent = e, this.data = r, this._path = n, this._key = s;
    }
    get path() {
      return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.
      push(...this._path, this._key)), this._cachedPath;
    }
  }, rs = /* @__PURE__ */ i((t, e) => {
    if ((0, u.isValid)(e))
      return { success: !0, data: e.value };
    if (!t.common.issues.length)
      throw new Error("Validation failed but no issues detected.");
    return {
      success: !1,
      get error() {
        if (this._error)
          return this._error;
        let r = new m.ZodError(t.common.issues);
        return this._error = r, this._error;
      }
    };
  }, "handleResult");
  function b(t) {
    if (!t)
      return {};
    let { errorMap: e, invalid_type_error: r, required_error: n, description: s } = t;
    if (e && (r || n))
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    return e ? { errorMap: e, description: s } : { errorMap: /* @__PURE__ */ i((a, c) => {
      var p, l;
      let { message: f } = t;
      return a.code === "invalid_enum_value" ? { message: f ?? c.defaultError } : typeof c.data > "u" ? { message: (p = f ?? n) !== null && p !==
      void 0 ? p : c.defaultError } : a.code !== "invalid_type" ? { message: c.defaultError } : { message: (l = f ?? r) !== null && l !== void 0 ?
      l : c.defaultError };
    }, "customMap"), description: s };
  }
  i(b, "processCreateParams");
  var v = class {
    static {
      i(this, "ZodType");
    }
    get description() {
      return this._def.description;
    }
    _getType(e) {
      return (0, h.getParsedType)(e.data);
    }
    _getOrReturnCtx(e, r) {
      return r || {
        common: e.parent.common,
        data: e.data,
        parsedType: (0, h.getParsedType)(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent
      };
    }
    _processInputParams(e) {
      return {
        status: new u.ParseStatus(),
        ctx: {
          common: e.parent.common,
          data: e.data,
          parsedType: (0, h.getParsedType)(e.data),
          schemaErrorMap: this._def.errorMap,
          path: e.path,
          parent: e.parent
        }
      };
    }
    _parseSync(e) {
      let r = this._parse(e);
      if ((0, u.isAsync)(r))
        throw new Error("Synchronous parse encountered promise.");
      return r;
    }
    _parseAsync(e) {
      let r = this._parse(e);
      return Promise.resolve(r);
    }
    parse(e, r) {
      let n = this.safeParse(e, r);
      if (n.success)
        return n.data;
      throw n.error;
    }
    safeParse(e, r) {
      var n;
      let s = {
        common: {
          issues: [],
          async: (n = r?.async) !== null && n !== void 0 ? n : !1,
          contextualErrorMap: r?.errorMap
        },
        path: r?.path || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: e,
        parsedType: (0, h.getParsedType)(e)
      }, o = this._parseSync({ data: e, path: s.path, parent: s });
      return rs(s, o);
    }
    "~validate"(e) {
      var r, n;
      let s = {
        common: {
          issues: [],
          async: !!this["~standard"].async
        },
        path: [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: e,
        parsedType: (0, h.getParsedType)(e)
      };
      if (!this["~standard"].async)
        try {
          let o = this._parseSync({ data: e, path: [], parent: s });
          return (0, u.isValid)(o) ? {
            value: o.value
          } : {
            issues: s.common.issues
          };
        } catch (o) {
          !((n = (r = o?.message) === null || r === void 0 ? void 0 : r.toLowerCase()) === null || n === void 0) && n.includes("encountered") &&
          (this["~standard"].async = !0), s.common = {
            issues: [],
            async: !0
          };
        }
      return this._parseAsync({ data: e, path: [], parent: s }).then((o) => (0, u.isValid)(o) ? {
        value: o.value
      } : {
        issues: s.common.issues
      });
    }
    async parseAsync(e, r) {
      let n = await this.safeParseAsync(e, r);
      if (n.success)
        return n.data;
      throw n.error;
    }
    async safeParseAsync(e, r) {
      let n = {
        common: {
          issues: [],
          contextualErrorMap: r?.errorMap,
          async: !0
        },
        path: r?.path || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: e,
        parsedType: (0, h.getParsedType)(e)
      }, s = this._parse({ data: e, path: n.path, parent: n }), o = await ((0, u.isAsync)(s) ? s : Promise.resolve(s));
      return rs(n, o);
    }
    refine(e, r) {
      let n = /* @__PURE__ */ i((s) => typeof r == "string" || typeof r > "u" ? { message: r } : typeof r == "function" ? r(s) : r, "getIssu\
eProperties");
      return this._refinement((s, o) => {
        let a = e(s), c = /* @__PURE__ */ i(() => o.addIssue({
          code: m.ZodIssueCode.custom,
          ...n(s)
        }), "setError");
        return typeof Promise < "u" && a instanceof Promise ? a.then((p) => p ? !0 : (c(), !1)) : a ? !0 : (c(), !1);
      });
    }
    refinement(e, r) {
      return this._refinement((n, s) => e(n) ? !0 : (s.addIssue(typeof r == "function" ? r(n, s) : r), !1));
    }
    _refinement(e) {
      return new Z({
        schema: this,
        typeName: g.ZodEffects,
        effect: { type: "refinement", refinement: e }
      });
    }
    superRefine(e) {
      return this._refinement(e);
    }
    constructor(e) {
      this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync =
      this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.
      bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.
      bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.
      promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(
      this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe =
      this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.
      bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = {
        version: 1,
        vendor: "zod",
        validate: /* @__PURE__ */ i((r) => this["~validate"](r), "validate")
      };
    }
    optional() {
      return L.create(this, this._def);
    }
    nullable() {
      return K.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return H.create(this);
    }
    promise() {
      return te.create(this, this._def);
    }
    or(e) {
      return fe.create([this, e], this._def);
    }
    and(e) {
      return me.create(this, e, this._def);
    }
    transform(e) {
      return new Z({
        ...b(this._def),
        schema: this,
        typeName: g.ZodEffects,
        effect: { type: "transform", transform: e }
      });
    }
    default(e) {
      let r = typeof e == "function" ? e : () => e;
      return new be({
        ...b(this._def),
        innerType: this,
        defaultValue: r,
        typeName: g.ZodDefault
      });
    }
    brand() {
      return new He({
        typeName: g.ZodBranded,
        type: this,
        ...b(this._def)
      });
    }
    catch(e) {
      let r = typeof e == "function" ? e : () => e;
      return new ve({
        ...b(this._def),
        innerType: this,
        catchValue: r,
        typeName: g.ZodCatch
      });
    }
    describe(e) {
      let r = this.constructor;
      return new r({
        ...this._def,
        description: e
      });
    }
    pipe(e) {
      return Xe.create(this, e);
    }
    readonly() {
      return _e.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  };
  d.ZodType = v;
  d.Schema = v;
  d.ZodSchema = v;
  var ec = /^c[^\s-]{8,}$/i, tc = /^[0-9a-z]+$/, rc = /^[0-9A-HJKMNP-TV-Z]{26}$/i, nc = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,
  sc = /^[a-z0-9_-]{21}$/i, oc = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/, ic = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,
  ac = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, cc = "^(\\p{Extended_Pictographic}|\\p{Emoji_Comp\
onent})+$", kr, dc = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, uc = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  lc = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/,
  pc = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  fc = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, mc = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  os = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469\
]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", hc = new RegExp(`^${os}$`);
  function is(t) {
    let e = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
    return t.precision ? e = `${e}\\.\\d{${t.precision}}` : t.precision == null && (e = `${e}(\\.\\d+)?`), e;
  }
  i(is, "timeRegexSource");
  function yc(t) {
    return new RegExp(`^${is(t)}$`);
  }
  i(yc, "timeRegex");
  function as(t) {
    let e = `${os}T${is(t)}`, r = [];
    return r.push(t.local ? "Z?" : "Z"), t.offset && r.push("([+-]\\d{2}:?\\d{2})"), e = `${e}(${r.join("|")})`, new RegExp(`^${e}$`);
  }
  i(as, "datetimeRegex");
  d.datetimeRegex = as;
  function gc(t, e) {
    return !!((e === "v4" || !e) && dc.test(t) || (e === "v6" || !e) && lc.test(t));
  }
  i(gc, "isValidIP");
  function xc(t, e) {
    if (!oc.test(t))
      return !1;
    try {
      let [r] = t.split("."), n = r.replace(/-/g, "+").replace(/_/g, "/").padEnd(r.length + (4 - r.length % 4) % 4, "="), s = JSON.parse(atob(
      n));
      return !(typeof s != "object" || s === null || !s.typ || !s.alg || e && s.alg !== e);
    } catch {
      return !1;
    }
  }
  i(xc, "isValidJWT");
  function bc(t, e) {
    return !!((e === "v4" || !e) && uc.test(t) || (e === "v6" || !e) && pc.test(t));
  }
  i(bc, "isValidCidr");
  var Q = class t extends v {
    static {
      i(this, "ZodString");
    }
    _parse(e) {
      if (this._def.coerce && (e.data = String(e.data)), this._getType(e) !== h.ZodParsedType.string) {
        let o = this._getOrReturnCtx(e);
        return (0, u.addIssueToContext)(o, {
          code: m.ZodIssueCode.invalid_type,
          expected: h.ZodParsedType.string,
          received: o.parsedType
        }), u.INVALID;
      }
      let n = new u.ParseStatus(), s;
      for (let o of this._def.checks)
        if (o.kind === "min")
          e.data.length < o.value && (s = this._getOrReturnCtx(e, s), (0, u.addIssueToContext)(s, {
            code: m.ZodIssueCode.too_small,
            minimum: o.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: o.message
          }), n.dirty());
        else if (o.kind === "max")
          e.data.length > o.value && (s = this._getOrReturnCtx(e, s), (0, u.addIssueToContext)(s, {
            code: m.ZodIssueCode.too_big,
            maximum: o.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: o.message
          }), n.dirty());
        else if (o.kind === "length") {
          let a = e.data.length > o.value, c = e.data.length < o.value;
          (a || c) && (s = this._getOrReturnCtx(e, s), a ? (0, u.addIssueToContext)(s, {
            code: m.ZodIssueCode.too_big,
            maximum: o.value,
            type: "string",
            inclusive: !0,
            exact: !0,
            message: o.message
          }) : c && (0, u.addIssueToContext)(s, {
            code: m.ZodIssueCode.too_small,
            minimum: o.value,
            type: "string",
            inclusive: !0,
            exact: !0,
            message: o.message
          }), n.dirty());
        } else if (o.kind === "email")
          ac.test(e.data) || (s = this._getOrReturnCtx(e, s), (0, u.addIssueToContext)(s, {
            validation: "email",
            code: m.ZodIssueCode.invalid_string,
            message: o.message
          }), n.dirty());
        else if (o.kind === "emoji")
          kr || (kr = new RegExp(cc, "u")), kr.test(e.data) || (s = this._getOrReturnCtx(e, s), (0, u.addIssueToContext)(s, {
            validation: "emoji",
            code: m.ZodIssueCode.invalid_string,
            message: o.message
          }), n.dirty());
        else if (o.kind === "uuid")
          nc.test(e.data) || (s = this._getOrReturnCtx(e, s), (0, u.addIssueToContext)(s, {
            validation: "uuid",
            code: m.ZodIssueCode.invalid_string,
            message: o.message
          }), n.dirty());
        else if (o.kind === "nanoid")
          sc.test(e.data) || (s = this._getOrReturnCtx(e, s), (0, u.addIssueToContext)(s, {
            validation: "nanoid",
            code: m.ZodIssueCode.invalid_string,
            message: o.message
          }), n.dirty());
        else if (o.kind === "cuid")
          ec.test(e.data) || (s = this._getOrReturnCtx(e, s), (0, u.addIssueToContext)(s, {
            validation: "cuid",
            code: m.ZodIssueCode.invalid_string,
            message: o.message
          }), n.dirty());
        else if (o.kind === "cuid2")
          tc.test(e.data) || (s = this._getOrReturnCtx(e, s), (0, u.addIssueToContext)(s, {
            validation: "cuid2",
            code: m.ZodIssueCode.invalid_string,
            message: o.message
          }), n.dirty());
        else if (o.kind === "ulid")
          rc.test(e.data) || (s = this._getOrReturnCtx(e, s), (0, u.addIssueToContext)(s, {
            validation: "ulid",
            code: m.ZodIssueCode.invalid_string,
            message: o.message
          }), n.dirty());
        else if (o.kind === "url")
          try {
            new URL(e.data);
          } catch {
            s = this._getOrReturnCtx(e, s), (0, u.addIssueToContext)(s, {
              validation: "url",
              code: m.ZodIssueCode.invalid_string,
              message: o.message
            }), n.dirty();
          }
        else o.kind === "regex" ? (o.regex.lastIndex = 0, o.regex.test(e.data) || (s = this._getOrReturnCtx(e, s), (0, u.addIssueToContext)(
        s, {
          validation: "regex",
          code: m.ZodIssueCode.invalid_string,
          message: o.message
        }), n.dirty())) : o.kind === "trim" ? e.data = e.data.trim() : o.kind === "includes" ? e.data.includes(o.value, o.position) || (s = this.
        _getOrReturnCtx(e, s), (0, u.addIssueToContext)(s, {
          code: m.ZodIssueCode.invalid_string,
          validation: { includes: o.value, position: o.position },
          message: o.message
        }), n.dirty()) : o.kind === "toLowerCase" ? e.data = e.data.toLowerCase() : o.kind === "toUpperCase" ? e.data = e.data.toUpperCase() :
        o.kind === "startsWith" ? e.data.startsWith(o.value) || (s = this._getOrReturnCtx(e, s), (0, u.addIssueToContext)(s, {
          code: m.ZodIssueCode.invalid_string,
          validation: { startsWith: o.value },
          message: o.message
        }), n.dirty()) : o.kind === "endsWith" ? e.data.endsWith(o.value) || (s = this._getOrReturnCtx(e, s), (0, u.addIssueToContext)(s, {
          code: m.ZodIssueCode.invalid_string,
          validation: { endsWith: o.value },
          message: o.message
        }), n.dirty()) : o.kind === "datetime" ? as(o).test(e.data) || (s = this._getOrReturnCtx(e, s), (0, u.addIssueToContext)(s, {
          code: m.ZodIssueCode.invalid_string,
          validation: "datetime",
          message: o.message
        }), n.dirty()) : o.kind === "date" ? hc.test(e.data) || (s = this._getOrReturnCtx(e, s), (0, u.addIssueToContext)(s, {
          code: m.ZodIssueCode.invalid_string,
          validation: "date",
          message: o.message
        }), n.dirty()) : o.kind === "time" ? yc(o).test(e.data) || (s = this._getOrReturnCtx(e, s), (0, u.addIssueToContext)(s, {
          code: m.ZodIssueCode.invalid_string,
          validation: "time",
          message: o.message
        }), n.dirty()) : o.kind === "duration" ? ic.test(e.data) || (s = this._getOrReturnCtx(e, s), (0, u.addIssueToContext)(s, {
          validation: "duration",
          code: m.ZodIssueCode.invalid_string,
          message: o.message
        }), n.dirty()) : o.kind === "ip" ? gc(e.data, o.version) || (s = this._getOrReturnCtx(e, s), (0, u.addIssueToContext)(s, {
          validation: "ip",
          code: m.ZodIssueCode.invalid_string,
          message: o.message
        }), n.dirty()) : o.kind === "jwt" ? xc(e.data, o.alg) || (s = this._getOrReturnCtx(e, s), (0, u.addIssueToContext)(s, {
          validation: "jwt",
          code: m.ZodIssueCode.invalid_string,
          message: o.message
        }), n.dirty()) : o.kind === "cidr" ? bc(e.data, o.version) || (s = this._getOrReturnCtx(e, s), (0, u.addIssueToContext)(s, {
          validation: "cidr",
          code: m.ZodIssueCode.invalid_string,
          message: o.message
        }), n.dirty()) : o.kind === "base64" ? fc.test(e.data) || (s = this._getOrReturnCtx(e, s), (0, u.addIssueToContext)(s, {
          validation: "base64",
          code: m.ZodIssueCode.invalid_string,
          message: o.message
        }), n.dirty()) : o.kind === "base64url" ? mc.test(e.data) || (s = this._getOrReturnCtx(e, s), (0, u.addIssueToContext)(s, {
          validation: "base64url",
          code: m.ZodIssueCode.invalid_string,
          message: o.message
        }), n.dirty()) : h.util.assertNever(o);
      return { status: n.value, value: e.data };
    }
    _regex(e, r, n) {
      return this.refinement((s) => e.test(s), {
        validation: r,
        code: m.ZodIssueCode.invalid_string,
        ...y.errorUtil.errToObj(n)
      });
    }
    _addCheck(e) {
      return new t({
        ...this._def,
        checks: [...this._def.checks, e]
      });
    }
    email(e) {
      return this._addCheck({ kind: "email", ...y.errorUtil.errToObj(e) });
    }
    url(e) {
      return this._addCheck({ kind: "url", ...y.errorUtil.errToObj(e) });
    }
    emoji(e) {
      return this._addCheck({ kind: "emoji", ...y.errorUtil.errToObj(e) });
    }
    uuid(e) {
      return this._addCheck({ kind: "uuid", ...y.errorUtil.errToObj(e) });
    }
    nanoid(e) {
      return this._addCheck({ kind: "nanoid", ...y.errorUtil.errToObj(e) });
    }
    cuid(e) {
      return this._addCheck({ kind: "cuid", ...y.errorUtil.errToObj(e) });
    }
    cuid2(e) {
      return this._addCheck({ kind: "cuid2", ...y.errorUtil.errToObj(e) });
    }
    ulid(e) {
      return this._addCheck({ kind: "ulid", ...y.errorUtil.errToObj(e) });
    }
    base64(e) {
      return this._addCheck({ kind: "base64", ...y.errorUtil.errToObj(e) });
    }
    base64url(e) {
      return this._addCheck({
        kind: "base64url",
        ...y.errorUtil.errToObj(e)
      });
    }
    jwt(e) {
      return this._addCheck({ kind: "jwt", ...y.errorUtil.errToObj(e) });
    }
    ip(e) {
      return this._addCheck({ kind: "ip", ...y.errorUtil.errToObj(e) });
    }
    cidr(e) {
      return this._addCheck({ kind: "cidr", ...y.errorUtil.errToObj(e) });
    }
    datetime(e) {
      var r, n;
      return typeof e == "string" ? this._addCheck({
        kind: "datetime",
        precision: null,
        offset: !1,
        local: !1,
        message: e
      }) : this._addCheck({
        kind: "datetime",
        precision: typeof e?.precision > "u" ? null : e?.precision,
        offset: (r = e?.offset) !== null && r !== void 0 ? r : !1,
        local: (n = e?.local) !== null && n !== void 0 ? n : !1,
        ...y.errorUtil.errToObj(e?.message)
      });
    }
    date(e) {
      return this._addCheck({ kind: "date", message: e });
    }
    time(e) {
      return typeof e == "string" ? this._addCheck({
        kind: "time",
        precision: null,
        message: e
      }) : this._addCheck({
        kind: "time",
        precision: typeof e?.precision > "u" ? null : e?.precision,
        ...y.errorUtil.errToObj(e?.message)
      });
    }
    duration(e) {
      return this._addCheck({ kind: "duration", ...y.errorUtil.errToObj(e) });
    }
    regex(e, r) {
      return this._addCheck({
        kind: "regex",
        regex: e,
        ...y.errorUtil.errToObj(r)
      });
    }
    includes(e, r) {
      return this._addCheck({
        kind: "includes",
        value: e,
        position: r?.position,
        ...y.errorUtil.errToObj(r?.message)
      });
    }
    startsWith(e, r) {
      return this._addCheck({
        kind: "startsWith",
        value: e,
        ...y.errorUtil.errToObj(r)
      });
    }
    endsWith(e, r) {
      return this._addCheck({
        kind: "endsWith",
        value: e,
        ...y.errorUtil.errToObj(r)
      });
    }
    min(e, r) {
      return this._addCheck({
        kind: "min",
        value: e,
        ...y.errorUtil.errToObj(r)
      });
    }
    max(e, r) {
      return this._addCheck({
        kind: "max",
        value: e,
        ...y.errorUtil.errToObj(r)
      });
    }
    length(e, r) {
      return this._addCheck({
        kind: "length",
        value: e,
        ...y.errorUtil.errToObj(r)
      });
    }
    /**
     * Equivalent to `.min(1)`
     */
    nonempty(e) {
      return this.min(1, y.errorUtil.errToObj(e));
    }
    trim() {
      return new t({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
    }
    toLowerCase() {
      return new t({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
    }
    toUpperCase() {
      return new t({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((e) => e.kind === "datetime");
    }
    get isDate() {
      return !!this._def.checks.find((e) => e.kind === "date");
    }
    get isTime() {
      return !!this._def.checks.find((e) => e.kind === "time");
    }
    get isDuration() {
      return !!this._def.checks.find((e) => e.kind === "duration");
    }
    get isEmail() {
      return !!this._def.checks.find((e) => e.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((e) => e.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((e) => e.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((e) => e.kind === "uuid");
    }
    get isNANOID() {
      return !!this._def.checks.find((e) => e.kind === "nanoid");
    }
    get isCUID() {
      return !!this._def.checks.find((e) => e.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((e) => e.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((e) => e.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((e) => e.kind === "ip");
    }
    get isCIDR() {
      return !!this._def.checks.find((e) => e.kind === "cidr");
    }
    get isBase64() {
      return !!this._def.checks.find((e) => e.kind === "base64");
    }
    get isBase64url() {
      return !!this._def.checks.find((e) => e.kind === "base64url");
    }
    get minLength() {
      let e = null;
      for (let r of this._def.checks)
        r.kind === "min" && (e === null || r.value > e) && (e = r.value);
      return e;
    }
    get maxLength() {
      let e = null;
      for (let r of this._def.checks)
        r.kind === "max" && (e === null || r.value < e) && (e = r.value);
      return e;
    }
  };
  d.ZodString = Q;
  Q.create = (t) => {
    var e;
    return new Q({
      checks: [],
      typeName: g.ZodString,
      coerce: (e = t?.coerce) !== null && e !== void 0 ? e : !1,
      ...b(t)
    });
  };
  function vc(t, e) {
    let r = (t.toString().split(".")[1] || "").length, n = (e.toString().split(".")[1] || "").length, s = r > n ? r : n, o = parseInt(t.toFixed(
    s).replace(".", "")), a = parseInt(e.toFixed(s).replace(".", ""));
    return o % a / Math.pow(10, s);
  }
  i(vc, "floatSafeRemainder");
  var ae = class t extends v {
    static {
      i(this, "ZodNumber");
    }
    constructor() {
      super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
    }
    _parse(e) {
      if (this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== h.ZodParsedType.number) {
        let o = this._getOrReturnCtx(e);
        return (0, u.addIssueToContext)(o, {
          code: m.ZodIssueCode.invalid_type,
          expected: h.ZodParsedType.number,
          received: o.parsedType
        }), u.INVALID;
      }
      let n, s = new u.ParseStatus();
      for (let o of this._def.checks)
        o.kind === "int" ? h.util.isInteger(e.data) || (n = this._getOrReturnCtx(e, n), (0, u.addIssueToContext)(n, {
          code: m.ZodIssueCode.invalid_type,
          expected: "integer",
          received: "float",
          message: o.message
        }), s.dirty()) : o.kind === "min" ? (o.inclusive ? e.data < o.value : e.data <= o.value) && (n = this._getOrReturnCtx(e, n), (0, u.addIssueToContext)(
        n, {
          code: m.ZodIssueCode.too_small,
          minimum: o.value,
          type: "number",
          inclusive: o.inclusive,
          exact: !1,
          message: o.message
        }), s.dirty()) : o.kind === "max" ? (o.inclusive ? e.data > o.value : e.data >= o.value) && (n = this._getOrReturnCtx(e, n), (0, u.addIssueToContext)(
        n, {
          code: m.ZodIssueCode.too_big,
          maximum: o.value,
          type: "number",
          inclusive: o.inclusive,
          exact: !1,
          message: o.message
        }), s.dirty()) : o.kind === "multipleOf" ? vc(e.data, o.value) !== 0 && (n = this._getOrReturnCtx(e, n), (0, u.addIssueToContext)(n,
        {
          code: m.ZodIssueCode.not_multiple_of,
          multipleOf: o.value,
          message: o.message
        }), s.dirty()) : o.kind === "finite" ? Number.isFinite(e.data) || (n = this._getOrReturnCtx(e, n), (0, u.addIssueToContext)(n, {
          code: m.ZodIssueCode.not_finite,
          message: o.message
        }), s.dirty()) : h.util.assertNever(o);
      return { status: s.value, value: e.data };
    }
    gte(e, r) {
      return this.setLimit("min", e, !0, y.errorUtil.toString(r));
    }
    gt(e, r) {
      return this.setLimit("min", e, !1, y.errorUtil.toString(r));
    }
    lte(e, r) {
      return this.setLimit("max", e, !0, y.errorUtil.toString(r));
    }
    lt(e, r) {
      return this.setLimit("max", e, !1, y.errorUtil.toString(r));
    }
    setLimit(e, r, n, s) {
      return new t({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind: e,
            value: r,
            inclusive: n,
            message: y.errorUtil.toString(s)
          }
        ]
      });
    }
    _addCheck(e) {
      return new t({
        ...this._def,
        checks: [...this._def.checks, e]
      });
    }
    int(e) {
      return this._addCheck({
        kind: "int",
        message: y.errorUtil.toString(e)
      });
    }
    positive(e) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: !1,
        message: y.errorUtil.toString(e)
      });
    }
    negative(e) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: !1,
        message: y.errorUtil.toString(e)
      });
    }
    nonpositive(e) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: !0,
        message: y.errorUtil.toString(e)
      });
    }
    nonnegative(e) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: !0,
        message: y.errorUtil.toString(e)
      });
    }
    multipleOf(e, r) {
      return this._addCheck({
        kind: "multipleOf",
        value: e,
        message: y.errorUtil.toString(r)
      });
    }
    finite(e) {
      return this._addCheck({
        kind: "finite",
        message: y.errorUtil.toString(e)
      });
    }
    safe(e) {
      return this._addCheck({
        kind: "min",
        inclusive: !0,
        value: Number.MIN_SAFE_INTEGER,
        message: y.errorUtil.toString(e)
      })._addCheck({
        kind: "max",
        inclusive: !0,
        value: Number.MAX_SAFE_INTEGER,
        message: y.errorUtil.toString(e)
      });
    }
    get minValue() {
      let e = null;
      for (let r of this._def.checks)
        r.kind === "min" && (e === null || r.value > e) && (e = r.value);
      return e;
    }
    get maxValue() {
      let e = null;
      for (let r of this._def.checks)
        r.kind === "max" && (e === null || r.value < e) && (e = r.value);
      return e;
    }
    get isInt() {
      return !!this._def.checks.find((e) => e.kind === "int" || e.kind === "multipleOf" && h.util.isInteger(e.value));
    }
    get isFinite() {
      let e = null, r = null;
      for (let n of this._def.checks) {
        if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf")
          return !0;
        n.kind === "min" ? (r === null || n.value > r) && (r = n.value) : n.kind === "max" && (e === null || n.value < e) && (e = n.value);
      }
      return Number.isFinite(r) && Number.isFinite(e);
    }
  };
  d.ZodNumber = ae;
  ae.create = (t) => new ae({
    checks: [],
    typeName: g.ZodNumber,
    coerce: t?.coerce || !1,
    ...b(t)
  });
  var ce = class t extends v {
    static {
      i(this, "ZodBigInt");
    }
    constructor() {
      super(...arguments), this.min = this.gte, this.max = this.lte;
    }
    _parse(e) {
      if (this._def.coerce)
        try {
          e.data = BigInt(e.data);
        } catch {
          return this._getInvalidInput(e);
        }
      if (this._getType(e) !== h.ZodParsedType.bigint)
        return this._getInvalidInput(e);
      let n, s = new u.ParseStatus();
      for (let o of this._def.checks)
        o.kind === "min" ? (o.inclusive ? e.data < o.value : e.data <= o.value) && (n = this._getOrReturnCtx(e, n), (0, u.addIssueToContext)(
        n, {
          code: m.ZodIssueCode.too_small,
          type: "bigint",
          minimum: o.value,
          inclusive: o.inclusive,
          message: o.message
        }), s.dirty()) : o.kind === "max" ? (o.inclusive ? e.data > o.value : e.data >= o.value) && (n = this._getOrReturnCtx(e, n), (0, u.addIssueToContext)(
        n, {
          code: m.ZodIssueCode.too_big,
          type: "bigint",
          maximum: o.value,
          inclusive: o.inclusive,
          message: o.message
        }), s.dirty()) : o.kind === "multipleOf" ? e.data % o.value !== BigInt(0) && (n = this._getOrReturnCtx(e, n), (0, u.addIssueToContext)(
        n, {
          code: m.ZodIssueCode.not_multiple_of,
          multipleOf: o.value,
          message: o.message
        }), s.dirty()) : h.util.assertNever(o);
      return { status: s.value, value: e.data };
    }
    _getInvalidInput(e) {
      let r = this._getOrReturnCtx(e);
      return (0, u.addIssueToContext)(r, {
        code: m.ZodIssueCode.invalid_type,
        expected: h.ZodParsedType.bigint,
        received: r.parsedType
      }), u.INVALID;
    }
    gte(e, r) {
      return this.setLimit("min", e, !0, y.errorUtil.toString(r));
    }
    gt(e, r) {
      return this.setLimit("min", e, !1, y.errorUtil.toString(r));
    }
    lte(e, r) {
      return this.setLimit("max", e, !0, y.errorUtil.toString(r));
    }
    lt(e, r) {
      return this.setLimit("max", e, !1, y.errorUtil.toString(r));
    }
    setLimit(e, r, n, s) {
      return new t({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind: e,
            value: r,
            inclusive: n,
            message: y.errorUtil.toString(s)
          }
        ]
      });
    }
    _addCheck(e) {
      return new t({
        ...this._def,
        checks: [...this._def.checks, e]
      });
    }
    positive(e) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: !1,
        message: y.errorUtil.toString(e)
      });
    }
    negative(e) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: !1,
        message: y.errorUtil.toString(e)
      });
    }
    nonpositive(e) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: !0,
        message: y.errorUtil.toString(e)
      });
    }
    nonnegative(e) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: !0,
        message: y.errorUtil.toString(e)
      });
    }
    multipleOf(e, r) {
      return this._addCheck({
        kind: "multipleOf",
        value: e,
        message: y.errorUtil.toString(r)
      });
    }
    get minValue() {
      let e = null;
      for (let r of this._def.checks)
        r.kind === "min" && (e === null || r.value > e) && (e = r.value);
      return e;
    }
    get maxValue() {
      let e = null;
      for (let r of this._def.checks)
        r.kind === "max" && (e === null || r.value < e) && (e = r.value);
      return e;
    }
  };
  d.ZodBigInt = ce;
  ce.create = (t) => {
    var e;
    return new ce({
      checks: [],
      typeName: g.ZodBigInt,
      coerce: (e = t?.coerce) !== null && e !== void 0 ? e : !1,
      ...b(t)
    });
  };
  var de = class extends v {
    static {
      i(this, "ZodBoolean");
    }
    _parse(e) {
      if (this._def.coerce && (e.data = !!e.data), this._getType(e) !== h.ZodParsedType.boolean) {
        let n = this._getOrReturnCtx(e);
        return (0, u.addIssueToContext)(n, {
          code: m.ZodIssueCode.invalid_type,
          expected: h.ZodParsedType.boolean,
          received: n.parsedType
        }), u.INVALID;
      }
      return (0, u.OK)(e.data);
    }
  };
  d.ZodBoolean = de;
  de.create = (t) => new de({
    typeName: g.ZodBoolean,
    coerce: t?.coerce || !1,
    ...b(t)
  });
  var ue = class t extends v {
    static {
      i(this, "ZodDate");
    }
    _parse(e) {
      if (this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== h.ZodParsedType.date) {
        let o = this._getOrReturnCtx(e);
        return (0, u.addIssueToContext)(o, {
          code: m.ZodIssueCode.invalid_type,
          expected: h.ZodParsedType.date,
          received: o.parsedType
        }), u.INVALID;
      }
      if (isNaN(e.data.getTime())) {
        let o = this._getOrReturnCtx(e);
        return (0, u.addIssueToContext)(o, {
          code: m.ZodIssueCode.invalid_date
        }), u.INVALID;
      }
      let n = new u.ParseStatus(), s;
      for (let o of this._def.checks)
        o.kind === "min" ? e.data.getTime() < o.value && (s = this._getOrReturnCtx(e, s), (0, u.addIssueToContext)(s, {
          code: m.ZodIssueCode.too_small,
          message: o.message,
          inclusive: !0,
          exact: !1,
          minimum: o.value,
          type: "date"
        }), n.dirty()) : o.kind === "max" ? e.data.getTime() > o.value && (s = this._getOrReturnCtx(e, s), (0, u.addIssueToContext)(s, {
          code: m.ZodIssueCode.too_big,
          message: o.message,
          inclusive: !0,
          exact: !1,
          maximum: o.value,
          type: "date"
        }), n.dirty()) : h.util.assertNever(o);
      return {
        status: n.value,
        value: new Date(e.data.getTime())
      };
    }
    _addCheck(e) {
      return new t({
        ...this._def,
        checks: [...this._def.checks, e]
      });
    }
    min(e, r) {
      return this._addCheck({
        kind: "min",
        value: e.getTime(),
        message: y.errorUtil.toString(r)
      });
    }
    max(e, r) {
      return this._addCheck({
        kind: "max",
        value: e.getTime(),
        message: y.errorUtil.toString(r)
      });
    }
    get minDate() {
      let e = null;
      for (let r of this._def.checks)
        r.kind === "min" && (e === null || r.value > e) && (e = r.value);
      return e != null ? new Date(e) : null;
    }
    get maxDate() {
      let e = null;
      for (let r of this._def.checks)
        r.kind === "max" && (e === null || r.value < e) && (e = r.value);
      return e != null ? new Date(e) : null;
    }
  };
  d.ZodDate = ue;
  ue.create = (t) => new ue({
    checks: [],
    coerce: t?.coerce || !1,
    typeName: g.ZodDate,
    ...b(t)
  });
  var Ee = class extends v {
    static {
      i(this, "ZodSymbol");
    }
    _parse(e) {
      if (this._getType(e) !== h.ZodParsedType.symbol) {
        let n = this._getOrReturnCtx(e);
        return (0, u.addIssueToContext)(n, {
          code: m.ZodIssueCode.invalid_type,
          expected: h.ZodParsedType.symbol,
          received: n.parsedType
        }), u.INVALID;
      }
      return (0, u.OK)(e.data);
    }
  };
  d.ZodSymbol = Ee;
  Ee.create = (t) => new Ee({
    typeName: g.ZodSymbol,
    ...b(t)
  });
  var le = class extends v {
    static {
      i(this, "ZodUndefined");
    }
    _parse(e) {
      if (this._getType(e) !== h.ZodParsedType.undefined) {
        let n = this._getOrReturnCtx(e);
        return (0, u.addIssueToContext)(n, {
          code: m.ZodIssueCode.invalid_type,
          expected: h.ZodParsedType.undefined,
          received: n.parsedType
        }), u.INVALID;
      }
      return (0, u.OK)(e.data);
    }
  };
  d.ZodUndefined = le;
  le.create = (t) => new le({
    typeName: g.ZodUndefined,
    ...b(t)
  });
  var pe = class extends v {
    static {
      i(this, "ZodNull");
    }
    _parse(e) {
      if (this._getType(e) !== h.ZodParsedType.null) {
        let n = this._getOrReturnCtx(e);
        return (0, u.addIssueToContext)(n, {
          code: m.ZodIssueCode.invalid_type,
          expected: h.ZodParsedType.null,
          received: n.parsedType
        }), u.INVALID;
      }
      return (0, u.OK)(e.data);
    }
  };
  d.ZodNull = pe;
  pe.create = (t) => new pe({
    typeName: g.ZodNull,
    ...b(t)
  });
  var ee = class extends v {
    static {
      i(this, "ZodAny");
    }
    constructor() {
      super(...arguments), this._any = !0;
    }
    _parse(e) {
      return (0, u.OK)(e.data);
    }
  };
  d.ZodAny = ee;
  ee.create = (t) => new ee({
    typeName: g.ZodAny,
    ...b(t)
  });
  var Y = class extends v {
    static {
      i(this, "ZodUnknown");
    }
    constructor() {
      super(...arguments), this._unknown = !0;
    }
    _parse(e) {
      return (0, u.OK)(e.data);
    }
  };
  d.ZodUnknown = Y;
  Y.create = (t) => new Y({
    typeName: g.ZodUnknown,
    ...b(t)
  });
  var $ = class extends v {
    static {
      i(this, "ZodNever");
    }
    _parse(e) {
      let r = this._getOrReturnCtx(e);
      return (0, u.addIssueToContext)(r, {
        code: m.ZodIssueCode.invalid_type,
        expected: h.ZodParsedType.never,
        received: r.parsedType
      }), u.INVALID;
    }
  };
  d.ZodNever = $;
  $.create = (t) => new $({
    typeName: g.ZodNever,
    ...b(t)
  });
  var Ce = class extends v {
    static {
      i(this, "ZodVoid");
    }
    _parse(e) {
      if (this._getType(e) !== h.ZodParsedType.undefined) {
        let n = this._getOrReturnCtx(e);
        return (0, u.addIssueToContext)(n, {
          code: m.ZodIssueCode.invalid_type,
          expected: h.ZodParsedType.void,
          received: n.parsedType
        }), u.INVALID;
      }
      return (0, u.OK)(e.data);
    }
  };
  d.ZodVoid = Ce;
  Ce.create = (t) => new Ce({
    typeName: g.ZodVoid,
    ...b(t)
  });
  var H = class t extends v {
    static {
      i(this, "ZodArray");
    }
    _parse(e) {
      let { ctx: r, status: n } = this._processInputParams(e), s = this._def;
      if (r.parsedType !== h.ZodParsedType.array)
        return (0, u.addIssueToContext)(r, {
          code: m.ZodIssueCode.invalid_type,
          expected: h.ZodParsedType.array,
          received: r.parsedType
        }), u.INVALID;
      if (s.exactLength !== null) {
        let a = r.data.length > s.exactLength.value, c = r.data.length < s.exactLength.value;
        (a || c) && ((0, u.addIssueToContext)(r, {
          code: a ? m.ZodIssueCode.too_big : m.ZodIssueCode.too_small,
          minimum: c ? s.exactLength.value : void 0,
          maximum: a ? s.exactLength.value : void 0,
          type: "array",
          inclusive: !0,
          exact: !0,
          message: s.exactLength.message
        }), n.dirty());
      }
      if (s.minLength !== null && r.data.length < s.minLength.value && ((0, u.addIssueToContext)(r, {
        code: m.ZodIssueCode.too_small,
        minimum: s.minLength.value,
        type: "array",
        inclusive: !0,
        exact: !1,
        message: s.minLength.message
      }), n.dirty()), s.maxLength !== null && r.data.length > s.maxLength.value && ((0, u.addIssueToContext)(r, {
        code: m.ZodIssueCode.too_big,
        maximum: s.maxLength.value,
        type: "array",
        inclusive: !0,
        exact: !1,
        message: s.maxLength.message
      }), n.dirty()), r.common.async)
        return Promise.all([...r.data].map((a, c) => s.type._parseAsync(new D(r, a, r.path, c)))).then((a) => u.ParseStatus.mergeArray(n, a));
      let o = [...r.data].map((a, c) => s.type._parseSync(new D(r, a, r.path, c)));
      return u.ParseStatus.mergeArray(n, o);
    }
    get element() {
      return this._def.type;
    }
    min(e, r) {
      return new t({
        ...this._def,
        minLength: { value: e, message: y.errorUtil.toString(r) }
      });
    }
    max(e, r) {
      return new t({
        ...this._def,
        maxLength: { value: e, message: y.errorUtil.toString(r) }
      });
    }
    length(e, r) {
      return new t({
        ...this._def,
        exactLength: { value: e, message: y.errorUtil.toString(r) }
      });
    }
    nonempty(e) {
      return this.min(1, e);
    }
  };
  d.ZodArray = H;
  H.create = (t, e) => new H({
    type: t,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: g.ZodArray,
    ...b(e)
  });
  function Se(t) {
    if (t instanceof R) {
      let e = {};
      for (let r in t.shape) {
        let n = t.shape[r];
        e[r] = L.create(Se(n));
      }
      return new R({
        ...t._def,
        shape: /* @__PURE__ */ i(() => e, "shape")
      });
    } else return t instanceof H ? new H({
      ...t._def,
      type: Se(t.element)
    }) : t instanceof L ? L.create(Se(t.unwrap())) : t instanceof K ? K.create(Se(t.unwrap())) : t instanceof G ? G.create(t.items.map((e) => Se(
    e))) : t;
  }
  i(Se, "deepPartialify");
  var R = class t extends v {
    static {
      i(this, "ZodObject");
    }
    constructor() {
      super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      let e = this._def.shape(), r = h.util.objectKeys(e);
      return this._cached = { shape: e, keys: r };
    }
    _parse(e) {
      if (this._getType(e) !== h.ZodParsedType.object) {
        let l = this._getOrReturnCtx(e);
        return (0, u.addIssueToContext)(l, {
          code: m.ZodIssueCode.invalid_type,
          expected: h.ZodParsedType.object,
          received: l.parsedType
        }), u.INVALID;
      }
      let { status: n, ctx: s } = this._processInputParams(e), { shape: o, keys: a } = this._getCached(), c = [];
      if (!(this._def.catchall instanceof $ && this._def.unknownKeys === "strip"))
        for (let l in s.data)
          a.includes(l) || c.push(l);
      let p = [];
      for (let l of a) {
        let f = o[l], x = s.data[l];
        p.push({
          key: { status: "valid", value: l },
          value: f._parse(new D(s, x, s.path, l)),
          alwaysSet: l in s.data
        });
      }
      if (this._def.catchall instanceof $) {
        let l = this._def.unknownKeys;
        if (l === "passthrough")
          for (let f of c)
            p.push({
              key: { status: "valid", value: f },
              value: { status: "valid", value: s.data[f] }
            });
        else if (l === "strict")
          c.length > 0 && ((0, u.addIssueToContext)(s, {
            code: m.ZodIssueCode.unrecognized_keys,
            keys: c
          }), n.dirty());
        else if (l !== "strip")
          throw new Error("Internal ZodObject error: invalid unknownKeys value.");
      } else {
        let l = this._def.catchall;
        for (let f of c) {
          let x = s.data[f];
          p.push({
            key: { status: "valid", value: f },
            value: l._parse(
              new D(s, x, s.path, f)
              //, ctx.child(key), value, getParsedType(value)
            ),
            alwaysSet: f in s.data
          });
        }
      }
      return s.common.async ? Promise.resolve().then(async () => {
        let l = [];
        for (let f of p) {
          let x = await f.key, w = await f.value;
          l.push({
            key: x,
            value: w,
            alwaysSet: f.alwaysSet
          });
        }
        return l;
      }).then((l) => u.ParseStatus.mergeObjectSync(n, l)) : u.ParseStatus.mergeObjectSync(n, p);
    }
    get shape() {
      return this._def.shape();
    }
    strict(e) {
      return y.errorUtil.errToObj, new t({
        ...this._def,
        unknownKeys: "strict",
        ...e !== void 0 ? {
          errorMap: /* @__PURE__ */ i((r, n) => {
            var s, o, a, c;
            let p = (a = (o = (s = this._def).errorMap) === null || o === void 0 ? void 0 : o.call(s, r, n).message) !== null && a !== void 0 ?
            a : n.defaultError;
            return r.code === "unrecognized_keys" ? {
              message: (c = y.errorUtil.errToObj(e).message) !== null && c !== void 0 ? c : p
            } : {
              message: p
            };
          }, "errorMap")
        } : {}
      });
    }
    strip() {
      return new t({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new t({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(e) {
      return new t({
        ...this._def,
        shape: /* @__PURE__ */ i(() => ({
          ...this._def.shape(),
          ...e
        }), "shape")
      });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(e) {
      return new t({
        unknownKeys: e._def.unknownKeys,
        catchall: e._def.catchall,
        shape: /* @__PURE__ */ i(() => ({
          ...this._def.shape(),
          ...e._def.shape()
        }), "shape"),
        typeName: g.ZodObject
      });
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(e, r) {
      return this.augment({ [e]: r });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(e) {
      return new t({
        ...this._def,
        catchall: e
      });
    }
    pick(e) {
      let r = {};
      return h.util.objectKeys(e).forEach((n) => {
        e[n] && this.shape[n] && (r[n] = this.shape[n]);
      }), new t({
        ...this._def,
        shape: /* @__PURE__ */ i(() => r, "shape")
      });
    }
    omit(e) {
      let r = {};
      return h.util.objectKeys(this.shape).forEach((n) => {
        e[n] || (r[n] = this.shape[n]);
      }), new t({
        ...this._def,
        shape: /* @__PURE__ */ i(() => r, "shape")
      });
    }
    /**
     * @deprecated
     */
    deepPartial() {
      return Se(this);
    }
    partial(e) {
      let r = {};
      return h.util.objectKeys(this.shape).forEach((n) => {
        let s = this.shape[n];
        e && !e[n] ? r[n] = s : r[n] = s.optional();
      }), new t({
        ...this._def,
        shape: /* @__PURE__ */ i(() => r, "shape")
      });
    }
    required(e) {
      let r = {};
      return h.util.objectKeys(this.shape).forEach((n) => {
        if (e && !e[n])
          r[n] = this.shape[n];
        else {
          let o = this.shape[n];
          for (; o instanceof L; )
            o = o._def.innerType;
          r[n] = o;
        }
      }), new t({
        ...this._def,
        shape: /* @__PURE__ */ i(() => r, "shape")
      });
    }
    keyof() {
      return cs(h.util.objectKeys(this.shape));
    }
  };
  d.ZodObject = R;
  R.create = (t, e) => new R({
    shape: /* @__PURE__ */ i(() => t, "shape"),
    unknownKeys: "strip",
    catchall: $.create(),
    typeName: g.ZodObject,
    ...b(e)
  });
  R.strictCreate = (t, e) => new R({
    shape: /* @__PURE__ */ i(() => t, "shape"),
    unknownKeys: "strict",
    catchall: $.create(),
    typeName: g.ZodObject,
    ...b(e)
  });
  R.lazycreate = (t, e) => new R({
    shape: t,
    unknownKeys: "strip",
    catchall: $.create(),
    typeName: g.ZodObject,
    ...b(e)
  });
  var fe = class extends v {
    static {
      i(this, "ZodUnion");
    }
    _parse(e) {
      let { ctx: r } = this._processInputParams(e), n = this._def.options;
      function s(o) {
        for (let c of o)
          if (c.result.status === "valid")
            return c.result;
        for (let c of o)
          if (c.result.status === "dirty")
            return r.common.issues.push(...c.ctx.common.issues), c.result;
        let a = o.map((c) => new m.ZodError(c.ctx.common.issues));
        return (0, u.addIssueToContext)(r, {
          code: m.ZodIssueCode.invalid_union,
          unionErrors: a
        }), u.INVALID;
      }
      if (i(s, "handleResults"), r.common.async)
        return Promise.all(n.map(async (o) => {
          let a = {
            ...r,
            common: {
              ...r.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await o._parseAsync({
              data: r.data,
              path: r.path,
              parent: a
            }),
            ctx: a
          };
        })).then(s);
      {
        let o, a = [];
        for (let p of n) {
          let l = {
            ...r,
            common: {
              ...r.common,
              issues: []
            },
            parent: null
          }, f = p._parseSync({
            data: r.data,
            path: r.path,
            parent: l
          });
          if (f.status === "valid")
            return f;
          f.status === "dirty" && !o && (o = { result: f, ctx: l }), l.common.issues.length && a.push(l.common.issues);
        }
        if (o)
          return r.common.issues.push(...o.ctx.common.issues), o.result;
        let c = a.map((p) => new m.ZodError(p));
        return (0, u.addIssueToContext)(r, {
          code: m.ZodIssueCode.invalid_union,
          unionErrors: c
        }), u.INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  };
  d.ZodUnion = fe;
  fe.create = (t, e) => new fe({
    options: t,
    typeName: g.ZodUnion,
    ...b(e)
  });
  var J = /* @__PURE__ */ i((t) => t instanceof he ? J(t.schema) : t instanceof Z ? J(t.innerType()) : t instanceof ye ? [t.value] : t instanceof
  ge ? t.options : t instanceof xe ? h.util.objectValues(t.enum) : t instanceof be ? J(t._def.innerType) : t instanceof le ? [void 0] : t instanceof
  pe ? [null] : t instanceof L ? [void 0, ...J(t.unwrap())] : t instanceof K ? [null, ...J(t.unwrap())] : t instanceof He || t instanceof _e ?
  J(t.unwrap()) : t instanceof ve ? J(t._def.innerType) : [], "getDiscriminator"), Ct = class t extends v {
    static {
      i(this, "ZodDiscriminatedUnion");
    }
    _parse(e) {
      let { ctx: r } = this._processInputParams(e);
      if (r.parsedType !== h.ZodParsedType.object)
        return (0, u.addIssueToContext)(r, {
          code: m.ZodIssueCode.invalid_type,
          expected: h.ZodParsedType.object,
          received: r.parsedType
        }), u.INVALID;
      let n = this.discriminator, s = r.data[n], o = this.optionsMap.get(s);
      return o ? r.common.async ? o._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      }) : o._parseSync({
        data: r.data,
        path: r.path,
        parent: r
      }) : ((0, u.addIssueToContext)(r, {
        code: m.ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [n]
      }), u.INVALID);
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(e, r, n) {
      let s = /* @__PURE__ */ new Map();
      for (let o of r) {
        let a = J(o.shape[e]);
        if (!a.length)
          throw new Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`);
        for (let c of a) {
          if (s.has(c))
            throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(c)}`);
          s.set(c, o);
        }
      }
      return new t({
        typeName: g.ZodDiscriminatedUnion,
        discriminator: e,
        options: r,
        optionsMap: s,
        ...b(n)
      });
    }
  };
  d.ZodDiscriminatedUnion = Ct;
  function Tr(t, e) {
    let r = (0, h.getParsedType)(t), n = (0, h.getParsedType)(e);
    if (t === e)
      return { valid: !0, data: t };
    if (r === h.ZodParsedType.object && n === h.ZodParsedType.object) {
      let s = h.util.objectKeys(e), o = h.util.objectKeys(t).filter((c) => s.indexOf(c) !== -1), a = { ...t, ...e };
      for (let c of o) {
        let p = Tr(t[c], e[c]);
        if (!p.valid)
          return { valid: !1 };
        a[c] = p.data;
      }
      return { valid: !0, data: a };
    } else if (r === h.ZodParsedType.array && n === h.ZodParsedType.array) {
      if (t.length !== e.length)
        return { valid: !1 };
      let s = [];
      for (let o = 0; o < t.length; o++) {
        let a = t[o], c = e[o], p = Tr(a, c);
        if (!p.valid)
          return { valid: !1 };
        s.push(p.data);
      }
      return { valid: !0, data: s };
    } else return r === h.ZodParsedType.date && n === h.ZodParsedType.date && +t == +e ? { valid: !0, data: t } : { valid: !1 };
  }
  i(Tr, "mergeValues");
  var me = class extends v {
    static {
      i(this, "ZodIntersection");
    }
    _parse(e) {
      let { status: r, ctx: n } = this._processInputParams(e), s = /* @__PURE__ */ i((o, a) => {
        if ((0, u.isAborted)(o) || (0, u.isAborted)(a))
          return u.INVALID;
        let c = Tr(o.value, a.value);
        return c.valid ? (((0, u.isDirty)(o) || (0, u.isDirty)(a)) && r.dirty(), { status: r.value, value: c.data }) : ((0, u.addIssueToContext)(
        n, {
          code: m.ZodIssueCode.invalid_intersection_types
        }), u.INVALID);
      }, "handleParsed");
      return n.common.async ? Promise.all([
        this._def.left._parseAsync({
          data: n.data,
          path: n.path,
          parent: n
        }),
        this._def.right._parseAsync({
          data: n.data,
          path: n.path,
          parent: n
        })
      ]).then(([o, a]) => s(o, a)) : s(this._def.left._parseSync({
        data: n.data,
        path: n.path,
        parent: n
      }), this._def.right._parseSync({
        data: n.data,
        path: n.path,
        parent: n
      }));
    }
  };
  d.ZodIntersection = me;
  me.create = (t, e, r) => new me({
    left: t,
    right: e,
    typeName: g.ZodIntersection,
    ...b(r)
  });
  var G = class t extends v {
    static {
      i(this, "ZodTuple");
    }
    _parse(e) {
      let { status: r, ctx: n } = this._processInputParams(e);
      if (n.parsedType !== h.ZodParsedType.array)
        return (0, u.addIssueToContext)(n, {
          code: m.ZodIssueCode.invalid_type,
          expected: h.ZodParsedType.array,
          received: n.parsedType
        }), u.INVALID;
      if (n.data.length < this._def.items.length)
        return (0, u.addIssueToContext)(n, {
          code: m.ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: !0,
          exact: !1,
          type: "array"
        }), u.INVALID;
      !this._def.rest && n.data.length > this._def.items.length && ((0, u.addIssueToContext)(n, {
        code: m.ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), r.dirty());
      let o = [...n.data].map((a, c) => {
        let p = this._def.items[c] || this._def.rest;
        return p ? p._parse(new D(n, a, n.path, c)) : null;
      }).filter((a) => !!a);
      return n.common.async ? Promise.all(o).then((a) => u.ParseStatus.mergeArray(r, a)) : u.ParseStatus.mergeArray(r, o);
    }
    get items() {
      return this._def.items;
    }
    rest(e) {
      return new t({
        ...this._def,
        rest: e
      });
    }
  };
  d.ZodTuple = G;
  G.create = (t, e) => {
    if (!Array.isArray(t))
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new G({
      items: t,
      typeName: g.ZodTuple,
      rest: null,
      ...b(e)
    });
  };
  var Pt = class t extends v {
    static {
      i(this, "ZodRecord");
    }
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(e) {
      let { status: r, ctx: n } = this._processInputParams(e);
      if (n.parsedType !== h.ZodParsedType.object)
        return (0, u.addIssueToContext)(n, {
          code: m.ZodIssueCode.invalid_type,
          expected: h.ZodParsedType.object,
          received: n.parsedType
        }), u.INVALID;
      let s = [], o = this._def.keyType, a = this._def.valueType;
      for (let c in n.data)
        s.push({
          key: o._parse(new D(n, c, n.path, c)),
          value: a._parse(new D(n, n.data[c], n.path, c)),
          alwaysSet: c in n.data
        });
      return n.common.async ? u.ParseStatus.mergeObjectAsync(r, s) : u.ParseStatus.mergeObjectSync(r, s);
    }
    get element() {
      return this._def.valueType;
    }
    static create(e, r, n) {
      return r instanceof v ? new t({
        keyType: e,
        valueType: r,
        typeName: g.ZodRecord,
        ...b(n)
      }) : new t({
        keyType: Q.create(),
        valueType: e,
        typeName: g.ZodRecord,
        ...b(r)
      });
    }
  };
  d.ZodRecord = Pt;
  var Pe = class extends v {
    static {
      i(this, "ZodMap");
    }
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(e) {
      let { status: r, ctx: n } = this._processInputParams(e);
      if (n.parsedType !== h.ZodParsedType.map)
        return (0, u.addIssueToContext)(n, {
          code: m.ZodIssueCode.invalid_type,
          expected: h.ZodParsedType.map,
          received: n.parsedType
        }), u.INVALID;
      let s = this._def.keyType, o = this._def.valueType, a = [...n.data.entries()].map(([c, p], l) => ({
        key: s._parse(new D(n, c, n.path, [l, "key"])),
        value: o._parse(new D(n, p, n.path, [l, "value"]))
      }));
      if (n.common.async) {
        let c = /* @__PURE__ */ new Map();
        return Promise.resolve().then(async () => {
          for (let p of a) {
            let l = await p.key, f = await p.value;
            if (l.status === "aborted" || f.status === "aborted")
              return u.INVALID;
            (l.status === "dirty" || f.status === "dirty") && r.dirty(), c.set(l.value, f.value);
          }
          return { status: r.value, value: c };
        });
      } else {
        let c = /* @__PURE__ */ new Map();
        for (let p of a) {
          let l = p.key, f = p.value;
          if (l.status === "aborted" || f.status === "aborted")
            return u.INVALID;
          (l.status === "dirty" || f.status === "dirty") && r.dirty(), c.set(l.value, f.value);
        }
        return { status: r.value, value: c };
      }
    }
  };
  d.ZodMap = Pe;
  Pe.create = (t, e, r) => new Pe({
    valueType: e,
    keyType: t,
    typeName: g.ZodMap,
    ...b(r)
  });
  var Ae = class t extends v {
    static {
      i(this, "ZodSet");
    }
    _parse(e) {
      let { status: r, ctx: n } = this._processInputParams(e);
      if (n.parsedType !== h.ZodParsedType.set)
        return (0, u.addIssueToContext)(n, {
          code: m.ZodIssueCode.invalid_type,
          expected: h.ZodParsedType.set,
          received: n.parsedType
        }), u.INVALID;
      let s = this._def;
      s.minSize !== null && n.data.size < s.minSize.value && ((0, u.addIssueToContext)(n, {
        code: m.ZodIssueCode.too_small,
        minimum: s.minSize.value,
        type: "set",
        inclusive: !0,
        exact: !1,
        message: s.minSize.message
      }), r.dirty()), s.maxSize !== null && n.data.size > s.maxSize.value && ((0, u.addIssueToContext)(n, {
        code: m.ZodIssueCode.too_big,
        maximum: s.maxSize.value,
        type: "set",
        inclusive: !0,
        exact: !1,
        message: s.maxSize.message
      }), r.dirty());
      let o = this._def.valueType;
      function a(p) {
        let l = /* @__PURE__ */ new Set();
        for (let f of p) {
          if (f.status === "aborted")
            return u.INVALID;
          f.status === "dirty" && r.dirty(), l.add(f.value);
        }
        return { status: r.value, value: l };
      }
      i(a, "finalizeSet");
      let c = [...n.data.values()].map((p, l) => o._parse(new D(n, p, n.path, l)));
      return n.common.async ? Promise.all(c).then((p) => a(p)) : a(c);
    }
    min(e, r) {
      return new t({
        ...this._def,
        minSize: { value: e, message: y.errorUtil.toString(r) }
      });
    }
    max(e, r) {
      return new t({
        ...this._def,
        maxSize: { value: e, message: y.errorUtil.toString(r) }
      });
    }
    size(e, r) {
      return this.min(e, r).max(e, r);
    }
    nonempty(e) {
      return this.min(1, e);
    }
  };
  d.ZodSet = Ae;
  Ae.create = (t, e) => new Ae({
    valueType: t,
    minSize: null,
    maxSize: null,
    typeName: g.ZodSet,
    ...b(e)
  });
  var At = class t extends v {
    static {
      i(this, "ZodFunction");
    }
    constructor() {
      super(...arguments), this.validate = this.implement;
    }
    _parse(e) {
      let { ctx: r } = this._processInputParams(e);
      if (r.parsedType !== h.ZodParsedType.function)
        return (0, u.addIssueToContext)(r, {
          code: m.ZodIssueCode.invalid_type,
          expected: h.ZodParsedType.function,
          received: r.parsedType
        }), u.INVALID;
      function n(c, p) {
        return (0, u.makeIssue)({
          data: c,
          path: r.path,
          errorMaps: [
            r.common.contextualErrorMap,
            r.schemaErrorMap,
            (0, St.getErrorMap)(),
            St.defaultErrorMap
          ].filter((l) => !!l),
          issueData: {
            code: m.ZodIssueCode.invalid_arguments,
            argumentsError: p
          }
        });
      }
      i(n, "makeArgsIssue");
      function s(c, p) {
        return (0, u.makeIssue)({
          data: c,
          path: r.path,
          errorMaps: [
            r.common.contextualErrorMap,
            r.schemaErrorMap,
            (0, St.getErrorMap)(),
            St.defaultErrorMap
          ].filter((l) => !!l),
          issueData: {
            code: m.ZodIssueCode.invalid_return_type,
            returnTypeError: p
          }
        });
      }
      i(s, "makeReturnsIssue");
      let o = { errorMap: r.common.contextualErrorMap }, a = r.data;
      if (this._def.returns instanceof te) {
        let c = this;
        return (0, u.OK)(async function(...p) {
          let l = new m.ZodError([]), f = await c._def.args.parseAsync(p, o).catch((_) => {
            throw l.addIssue(n(p, _)), l;
          }), x = await Reflect.apply(a, this, f);
          return await c._def.returns._def.type.parseAsync(x, o).catch((_) => {
            throw l.addIssue(s(x, _)), l;
          });
        });
      } else {
        let c = this;
        return (0, u.OK)(function(...p) {
          let l = c._def.args.safeParse(p, o);
          if (!l.success)
            throw new m.ZodError([n(p, l.error)]);
          let f = Reflect.apply(a, this, l.data), x = c._def.returns.safeParse(f, o);
          if (!x.success)
            throw new m.ZodError([s(f, x.error)]);
          return x.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...e) {
      return new t({
        ...this._def,
        args: G.create(e).rest(Y.create())
      });
    }
    returns(e) {
      return new t({
        ...this._def,
        returns: e
      });
    }
    implement(e) {
      return this.parse(e);
    }
    strictImplement(e) {
      return this.parse(e);
    }
    static create(e, r, n) {
      return new t({
        args: e || G.create([]).rest(Y.create()),
        returns: r || Y.create(),
        typeName: g.ZodFunction,
        ...b(n)
      });
    }
  };
  d.ZodFunction = At;
  var he = class extends v {
    static {
      i(this, "ZodLazy");
    }
    get schema() {
      return this._def.getter();
    }
    _parse(e) {
      let { ctx: r } = this._processInputParams(e);
      return this._def.getter()._parse({ data: r.data, path: r.path, parent: r });
    }
  };
  d.ZodLazy = he;
  he.create = (t, e) => new he({
    getter: t,
    typeName: g.ZodLazy,
    ...b(e)
  });
  var ye = class extends v {
    static {
      i(this, "ZodLiteral");
    }
    _parse(e) {
      if (e.data !== this._def.value) {
        let r = this._getOrReturnCtx(e);
        return (0, u.addIssueToContext)(r, {
          received: r.data,
          code: m.ZodIssueCode.invalid_literal,
          expected: this._def.value
        }), u.INVALID;
      }
      return { status: "valid", value: e.data };
    }
    get value() {
      return this._def.value;
    }
  };
  d.ZodLiteral = ye;
  ye.create = (t, e) => new ye({
    value: t,
    typeName: g.ZodLiteral,
    ...b(e)
  });
  function cs(t, e) {
    return new ge({
      values: t,
      typeName: g.ZodEnum,
      ...b(e)
    });
  }
  i(cs, "createZodEnum");
  var ge = class t extends v {
    static {
      i(this, "ZodEnum");
    }
    constructor() {
      super(...arguments), Je.set(this, void 0);
    }
    _parse(e) {
      if (typeof e.data != "string") {
        let r = this._getOrReturnCtx(e), n = this._def.values;
        return (0, u.addIssueToContext)(r, {
          expected: h.util.joinValues(n),
          received: r.parsedType,
          code: m.ZodIssueCode.invalid_type
        }), u.INVALID;
      }
      if (Et(this, Je, "f") || ss(this, Je, new Set(this._def.values), "f"), !Et(this, Je, "f").has(e.data)) {
        let r = this._getOrReturnCtx(e), n = this._def.values;
        return (0, u.addIssueToContext)(r, {
          received: r.data,
          code: m.ZodIssueCode.invalid_enum_value,
          options: n
        }), u.INVALID;
      }
      return (0, u.OK)(e.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      let e = {};
      for (let r of this._def.values)
        e[r] = r;
      return e;
    }
    get Values() {
      let e = {};
      for (let r of this._def.values)
        e[r] = r;
      return e;
    }
    get Enum() {
      let e = {};
      for (let r of this._def.values)
        e[r] = r;
      return e;
    }
    extract(e, r = this._def) {
      return t.create(e, {
        ...this._def,
        ...r
      });
    }
    exclude(e, r = this._def) {
      return t.create(this.options.filter((n) => !e.includes(n)), {
        ...this._def,
        ...r
      });
    }
  };
  d.ZodEnum = ge;
  Je = /* @__PURE__ */ new WeakMap();
  ge.create = cs;
  var xe = class extends v {
    static {
      i(this, "ZodNativeEnum");
    }
    constructor() {
      super(...arguments), Ye.set(this, void 0);
    }
    _parse(e) {
      let r = h.util.getValidEnumValues(this._def.values), n = this._getOrReturnCtx(e);
      if (n.parsedType !== h.ZodParsedType.string && n.parsedType !== h.ZodParsedType.number) {
        let s = h.util.objectValues(r);
        return (0, u.addIssueToContext)(n, {
          expected: h.util.joinValues(s),
          received: n.parsedType,
          code: m.ZodIssueCode.invalid_type
        }), u.INVALID;
      }
      if (Et(this, Ye, "f") || ss(this, Ye, new Set(h.util.getValidEnumValues(this._def.values)), "f"), !Et(this, Ye, "f").has(e.data)) {
        let s = h.util.objectValues(r);
        return (0, u.addIssueToContext)(n, {
          received: n.data,
          code: m.ZodIssueCode.invalid_enum_value,
          options: s
        }), u.INVALID;
      }
      return (0, u.OK)(e.data);
    }
    get enum() {
      return this._def.values;
    }
  };
  d.ZodNativeEnum = xe;
  Ye = /* @__PURE__ */ new WeakMap();
  xe.create = (t, e) => new xe({
    values: t,
    typeName: g.ZodNativeEnum,
    ...b(e)
  });
  var te = class extends v {
    static {
      i(this, "ZodPromise");
    }
    unwrap() {
      return this._def.type;
    }
    _parse(e) {
      let { ctx: r } = this._processInputParams(e);
      if (r.parsedType !== h.ZodParsedType.promise && r.common.async === !1)
        return (0, u.addIssueToContext)(r, {
          code: m.ZodIssueCode.invalid_type,
          expected: h.ZodParsedType.promise,
          received: r.parsedType
        }), u.INVALID;
      let n = r.parsedType === h.ZodParsedType.promise ? r.data : Promise.resolve(r.data);
      return (0, u.OK)(n.then((s) => this._def.type.parseAsync(s, {
        path: r.path,
        errorMap: r.common.contextualErrorMap
      })));
    }
  };
  d.ZodPromise = te;
  te.create = (t, e) => new te({
    type: t,
    typeName: g.ZodPromise,
    ...b(e)
  });
  var Z = class extends v {
    static {
      i(this, "ZodEffects");
    }
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === g.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(e) {
      let { status: r, ctx: n } = this._processInputParams(e), s = this._def.effect || null, o = {
        addIssue: /* @__PURE__ */ i((a) => {
          (0, u.addIssueToContext)(n, a), a.fatal ? r.abort() : r.dirty();
        }, "addIssue"),
        get path() {
          return n.path;
        }
      };
      if (o.addIssue = o.addIssue.bind(o), s.type === "preprocess") {
        let a = s.transform(n.data, o);
        if (n.common.async)
          return Promise.resolve(a).then(async (c) => {
            if (r.value === "aborted")
              return u.INVALID;
            let p = await this._def.schema._parseAsync({
              data: c,
              path: n.path,
              parent: n
            });
            return p.status === "aborted" ? u.INVALID : p.status === "dirty" || r.value === "dirty" ? (0, u.DIRTY)(p.value) : p;
          });
        {
          if (r.value === "aborted")
            return u.INVALID;
          let c = this._def.schema._parseSync({
            data: a,
            path: n.path,
            parent: n
          });
          return c.status === "aborted" ? u.INVALID : c.status === "dirty" || r.value === "dirty" ? (0, u.DIRTY)(c.value) : c;
        }
      }
      if (s.type === "refinement") {
        let a = /* @__PURE__ */ i((c) => {
          let p = s.refinement(c, o);
          if (n.common.async)
            return Promise.resolve(p);
          if (p instanceof Promise)
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          return c;
        }, "executeRefinement");
        if (n.common.async === !1) {
          let c = this._def.schema._parseSync({
            data: n.data,
            path: n.path,
            parent: n
          });
          return c.status === "aborted" ? u.INVALID : (c.status === "dirty" && r.dirty(), a(c.value), { status: r.value, value: c.value });
        } else
          return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((c) => c.status === "aborted" ? u.INVALID : (c.
          status === "dirty" && r.dirty(), a(c.value).then(() => ({ status: r.value, value: c.value }))));
      }
      if (s.type === "transform")
        if (n.common.async === !1) {
          let a = this._def.schema._parseSync({
            data: n.data,
            path: n.path,
            parent: n
          });
          if (!(0, u.isValid)(a))
            return a;
          let c = s.transform(a.value, o);
          if (c instanceof Promise)
            throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
          return { status: r.value, value: c };
        } else
          return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((a) => (0, u.isValid)(a) ? Promise.resolve(s.transform(
          a.value, o)).then((c) => ({ status: r.value, value: c })) : a);
      h.util.assertNever(s);
    }
  };
  d.ZodEffects = Z;
  d.ZodTransformer = Z;
  Z.create = (t, e, r) => new Z({
    schema: t,
    typeName: g.ZodEffects,
    effect: e,
    ...b(r)
  });
  Z.createWithPreprocess = (t, e, r) => new Z({
    schema: e,
    effect: { type: "preprocess", transform: t },
    typeName: g.ZodEffects,
    ...b(r)
  });
  var L = class extends v {
    static {
      i(this, "ZodOptional");
    }
    _parse(e) {
      return this._getType(e) === h.ZodParsedType.undefined ? (0, u.OK)(void 0) : this._def.innerType._parse(e);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  d.ZodOptional = L;
  L.create = (t, e) => new L({
    innerType: t,
    typeName: g.ZodOptional,
    ...b(e)
  });
  var K = class extends v {
    static {
      i(this, "ZodNullable");
    }
    _parse(e) {
      return this._getType(e) === h.ZodParsedType.null ? (0, u.OK)(null) : this._def.innerType._parse(e);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  d.ZodNullable = K;
  K.create = (t, e) => new K({
    innerType: t,
    typeName: g.ZodNullable,
    ...b(e)
  });
  var be = class extends v {
    static {
      i(this, "ZodDefault");
    }
    _parse(e) {
      let { ctx: r } = this._processInputParams(e), n = r.data;
      return r.parsedType === h.ZodParsedType.undefined && (n = this._def.defaultValue()), this._def.innerType._parse({
        data: n,
        path: r.path,
        parent: r
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  };
  d.ZodDefault = be;
  be.create = (t, e) => new be({
    innerType: t,
    typeName: g.ZodDefault,
    defaultValue: typeof e.default == "function" ? e.default : () => e.default,
    ...b(e)
  });
  var ve = class extends v {
    static {
      i(this, "ZodCatch");
    }
    _parse(e) {
      let { ctx: r } = this._processInputParams(e), n = {
        ...r,
        common: {
          ...r.common,
          issues: []
        }
      }, s = this._def.innerType._parse({
        data: n.data,
        path: n.path,
        parent: {
          ...n
        }
      });
      return (0, u.isAsync)(s) ? s.then((o) => ({
        status: "valid",
        value: o.status === "valid" ? o.value : this._def.catchValue({
          get error() {
            return new m.ZodError(n.common.issues);
          },
          input: n.data
        })
      })) : {
        status: "valid",
        value: s.status === "valid" ? s.value : this._def.catchValue({
          get error() {
            return new m.ZodError(n.common.issues);
          },
          input: n.data
        })
      };
    }
    removeCatch() {
      return this._def.innerType;
    }
  };
  d.ZodCatch = ve;
  ve.create = (t, e) => new ve({
    innerType: t,
    typeName: g.ZodCatch,
    catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
    ...b(e)
  });
  var Oe = class extends v {
    static {
      i(this, "ZodNaN");
    }
    _parse(e) {
      if (this._getType(e) !== h.ZodParsedType.nan) {
        let n = this._getOrReturnCtx(e);
        return (0, u.addIssueToContext)(n, {
          code: m.ZodIssueCode.invalid_type,
          expected: h.ZodParsedType.nan,
          received: n.parsedType
        }), u.INVALID;
      }
      return { status: "valid", value: e.data };
    }
  };
  d.ZodNaN = Oe;
  Oe.create = (t) => new Oe({
    typeName: g.ZodNaN,
    ...b(t)
  });
  d.BRAND = Symbol("zod_brand");
  var He = class extends v {
    static {
      i(this, "ZodBranded");
    }
    _parse(e) {
      let { ctx: r } = this._processInputParams(e), n = r.data;
      return this._def.type._parse({
        data: n,
        path: r.path,
        parent: r
      });
    }
    unwrap() {
      return this._def.type;
    }
  };
  d.ZodBranded = He;
  var Xe = class t extends v {
    static {
      i(this, "ZodPipeline");
    }
    _parse(e) {
      let { status: r, ctx: n } = this._processInputParams(e);
      if (n.common.async)
        return (/* @__PURE__ */ i(async () => {
          let o = await this._def.in._parseAsync({
            data: n.data,
            path: n.path,
            parent: n
          });
          return o.status === "aborted" ? u.INVALID : o.status === "dirty" ? (r.dirty(), (0, u.DIRTY)(o.value)) : this._def.out._parseAsync(
          {
            data: o.value,
            path: n.path,
            parent: n
          });
        }, "handleAsync"))();
      {
        let s = this._def.in._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return s.status === "aborted" ? u.INVALID : s.status === "dirty" ? (r.dirty(), {
          status: "dirty",
          value: s.value
        }) : this._def.out._parseSync({
          data: s.value,
          path: n.path,
          parent: n
        });
      }
    }
    static create(e, r) {
      return new t({
        in: e,
        out: r,
        typeName: g.ZodPipeline
      });
    }
  };
  d.ZodPipeline = Xe;
  var _e = class extends v {
    static {
      i(this, "ZodReadonly");
    }
    _parse(e) {
      let r = this._def.innerType._parse(e), n = /* @__PURE__ */ i((s) => ((0, u.isValid)(s) && (s.value = Object.freeze(s.value)), s), "fre\
eze");
      return (0, u.isAsync)(r) ? r.then((s) => n(s)) : n(r);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  d.ZodReadonly = _e;
  _e.create = (t, e) => new _e({
    innerType: t,
    typeName: g.ZodReadonly,
    ...b(e)
  });
  function ns(t, e) {
    let r = typeof t == "function" ? t(e) : typeof t == "string" ? { message: t } : t;
    return typeof r == "string" ? { message: r } : r;
  }
  i(ns, "cleanParams");
  function ds(t, e = {}, r) {
    return t ? ee.create().superRefine((n, s) => {
      var o, a;
      let c = t(n);
      if (c instanceof Promise)
        return c.then((p) => {
          var l, f;
          if (!p) {
            let x = ns(e, n), w = (f = (l = x.fatal) !== null && l !== void 0 ? l : r) !== null && f !== void 0 ? f : !0;
            s.addIssue({ code: "custom", ...x, fatal: w });
          }
        });
      if (!c) {
        let p = ns(e, n), l = (a = (o = p.fatal) !== null && o !== void 0 ? o : r) !== null && a !== void 0 ? a : !0;
        s.addIssue({ code: "custom", ...p, fatal: l });
      }
    }) : ee.create();
  }
  i(ds, "custom");
  d.custom = ds;
  d.late = {
    object: R.lazycreate
  };
  var g;
  (function(t) {
    t.ZodString = "ZodString", t.ZodNumber = "ZodNumber", t.ZodNaN = "ZodNaN", t.ZodBigInt = "ZodBigInt", t.ZodBoolean = "ZodBoolean", t.ZodDate =
    "ZodDate", t.ZodSymbol = "ZodSymbol", t.ZodUndefined = "ZodUndefined", t.ZodNull = "ZodNull", t.ZodAny = "ZodAny", t.ZodUnknown = "ZodUn\
known", t.ZodNever = "ZodNever", t.ZodVoid = "ZodVoid", t.ZodArray = "ZodArray", t.ZodObject = "ZodObject", t.ZodUnion = "ZodUnion", t.ZodDiscriminatedUnion =
    "ZodDiscriminatedUnion", t.ZodIntersection = "ZodIntersection", t.ZodTuple = "ZodTuple", t.ZodRecord = "ZodRecord", t.ZodMap = "ZodMap",
    t.ZodSet = "ZodSet", t.ZodFunction = "ZodFunction", t.ZodLazy = "ZodLazy", t.ZodLiteral = "ZodLiteral", t.ZodEnum = "ZodEnum", t.ZodEffects =
    "ZodEffects", t.ZodNativeEnum = "ZodNativeEnum", t.ZodOptional = "ZodOptional", t.ZodNullable = "ZodNullable", t.ZodDefault = "ZodDefaul\
t", t.ZodCatch = "ZodCatch", t.ZodPromise = "ZodPromise", t.ZodBranded = "ZodBranded", t.ZodPipeline = "ZodPipeline", t.ZodReadonly = "ZodRe\
adonly";
  })(g || (d.ZodFirstPartyTypeKind = g = {}));
  var _c = /* @__PURE__ */ i((t, e = {
    message: `Input not instance of ${t.name}`
  }) => ds((r) => r instanceof t, e), "instanceOfType");
  d.instanceof = _c;
  var us = Q.create;
  d.string = us;
  var ls = ae.create;
  d.number = ls;
  var wc = Oe.create;
  d.nan = wc;
  var kc = ce.create;
  d.bigint = kc;
  var ps = de.create;
  d.boolean = ps;
  var Tc = ue.create;
  d.date = Tc;
  var Ic = Ee.create;
  d.symbol = Ic;
  var Sc = le.create;
  d.undefined = Sc;
  var Ec = pe.create;
  d.null = Ec;
  var Cc = ee.create;
  d.any = Cc;
  var Pc = Y.create;
  d.unknown = Pc;
  var Ac = $.create;
  d.never = Ac;
  var Oc = Ce.create;
  d.void = Oc;
  var jc = H.create;
  d.array = jc;
  var Rc = R.create;
  d.object = Rc;
  var Nc = R.strictCreate;
  d.strictObject = Nc;
  var Zc = fe.create;
  d.union = Zc;
  var Mc = Ct.create;
  d.discriminatedUnion = Mc;
  var Lc = me.create;
  d.intersection = Lc;
  var Dc = G.create;
  d.tuple = Dc;
  var Uc = Pt.create;
  d.record = Uc;
  var $c = Pe.create;
  d.map = $c;
  var Vc = Ae.create;
  d.set = Vc;
  var Fc = At.create;
  d.function = Fc;
  var Bc = he.create;
  d.lazy = Bc;
  var Wc = ye.create;
  d.literal = Wc;
  var qc = ge.create;
  d.enum = qc;
  var Gc = xe.create;
  d.nativeEnum = Gc;
  var Kc = te.create;
  d.promise = Kc;
  var fs = Z.create;
  d.effect = fs;
  d.transformer = fs;
  var zc = L.create;
  d.optional = zc;
  var Jc = K.create;
  d.nullable = Jc;
  var Yc = Z.createWithPreprocess;
  d.preprocess = Yc;
  var Hc = Xe.create;
  d.pipeline = Hc;
  var Xc = /* @__PURE__ */ i(() => us().optional(), "ostring");
  d.ostring = Xc;
  var Qc = /* @__PURE__ */ i(() => ls().optional(), "onumber");
  d.onumber = Qc;
  var ed = /* @__PURE__ */ i(() => ps().optional(), "oboolean");
  d.oboolean = ed;
  d.coerce = {
    string: /* @__PURE__ */ i((t) => Q.create({ ...t, coerce: !0 }), "string"),
    number: /* @__PURE__ */ i((t) => ae.create({ ...t, coerce: !0 }), "number"),
    boolean: /* @__PURE__ */ i((t) => de.create({
      ...t,
      coerce: !0
    }), "boolean"),
    bigint: /* @__PURE__ */ i((t) => ce.create({ ...t, coerce: !0 }), "bigint"),
    date: /* @__PURE__ */ i((t) => ue.create({ ...t, coerce: !0 }), "date")
  };
  d.NEVER = u.INVALID;
});

// ../node_modules/zod/lib/external.js
var Ir = S((U) => {
  "use strict";
  var td = U && U.__createBinding || (Object.create ? function(t, e, r, n) {
    n === void 0 && (n = r);
    var s = Object.getOwnPropertyDescriptor(e, r);
    (!s || ("get" in s ? !e.__esModule : s.writable || s.configurable)) && (s = { enumerable: !0, get: /* @__PURE__ */ i(function() {
      return e[r];
    }, "get") }), Object.defineProperty(t, n, s);
  } : function(t, e, r, n) {
    n === void 0 && (n = r), t[n] = e[r];
  }), je = U && U.__exportStar || function(t, e) {
    for (var r in t) r !== "default" && !Object.prototype.hasOwnProperty.call(e, r) && td(e, t, r);
  };
  Object.defineProperty(U, "__esModule", { value: !0 });
  je(Tt(), U);
  je(wr(), U);
  je(Qn(), U);
  je(Ke(), U);
  je(ms(), U);
  je(kt(), U);
});

// ../node_modules/zod/lib/index.js
var gs = S((N) => {
  "use strict";
  var hs = N && N.__createBinding || (Object.create ? function(t, e, r, n) {
    n === void 0 && (n = r);
    var s = Object.getOwnPropertyDescriptor(e, r);
    (!s || ("get" in s ? !e.__esModule : s.writable || s.configurable)) && (s = { enumerable: !0, get: /* @__PURE__ */ i(function() {
      return e[r];
    }, "get") }), Object.defineProperty(t, n, s);
  } : function(t, e, r, n) {
    n === void 0 && (n = r), t[n] = e[r];
  }), rd = N && N.__setModuleDefault || (Object.create ? function(t, e) {
    Object.defineProperty(t, "default", { enumerable: !0, value: e });
  } : function(t, e) {
    t.default = e;
  }), nd = N && N.__importStar || function(t) {
    if (t && t.__esModule) return t;
    var e = {};
    if (t != null) for (var r in t) r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && hs(e, t, r);
    return rd(e, t), e;
  }, sd = N && N.__exportStar || function(t, e) {
    for (var r in t) r !== "default" && !Object.prototype.hasOwnProperty.call(e, r) && hs(e, t, r);
  };
  Object.defineProperty(N, "__esModule", { value: !0 });
  N.z = void 0;
  var ys = nd(Ir());
  N.z = ys;
  sd(Ir(), N);
  N.default = ys;
});

// ../node_modules/ts-dedent/dist/index.js
var bs = S((Qe) => {
  "use strict";
  Object.defineProperty(Qe, "__esModule", { value: !0 });
  Qe.dedent = void 0;
  function xs(t) {
    for (var e = [], r = 1; r < arguments.length; r++)
      e[r - 1] = arguments[r];
    var n = Array.from(typeof t == "string" ? [t] : t);
    n[n.length - 1] = n[n.length - 1].replace(/\r?\n([\t ]*)$/, "");
    var s = n.reduce(function(c, p) {
      var l = p.match(/\n([\t ]+|(?!\s).)/g);
      return l ? c.concat(l.map(function(f) {
        var x, w;
        return (w = (x = f.match(/[\t ]/g)) === null || x === void 0 ? void 0 : x.length) !== null && w !== void 0 ? w : 0;
      })) : c;
    }, []);
    if (s.length) {
      var o = new RegExp(`
[	 ]{` + Math.min.apply(Math, s) + "}", "g");
      n = n.map(function(c) {
        return c.replace(o, `
`);
      });
    }
    n[0] = n[0].replace(/^\r?\n/, "");
    var a = n[0];
    return e.forEach(function(c, p) {
      var l = a.match(/(?:^|\n)( *)$/), f = l ? l[1] : "", x = c;
      typeof c == "string" && c.includes(`
`) && (x = String(c).split(`
`).map(function(w, _) {
        return _ === 0 ? w : "" + f + w;
      }).join(`
`)), a += x + n[p + 1];
    }), a;
  }
  i(xs, "dedent");
  Qe.dedent = xs;
  Qe.default = xs;
});

// ../node_modules/isexe/windows.js
var Cs = S((yp, Es) => {
  Es.exports = Ss;
  Ss.sync = dd;
  var Ts = require("fs");
  function cd(t, e) {
    var r = e.pathExt !== void 0 ? e.pathExt : process.env.PATHEXT;
    if (!r || (r = r.split(";"), r.indexOf("") !== -1))
      return !0;
    for (var n = 0; n < r.length; n++) {
      var s = r[n].toLowerCase();
      if (s && t.substr(-s.length).toLowerCase() === s)
        return !0;
    }
    return !1;
  }
  i(cd, "checkPathExt");
  function Is(t, e, r) {
    return !t.isSymbolicLink() && !t.isFile() ? !1 : cd(e, r);
  }
  i(Is, "checkStat");
  function Ss(t, e, r) {
    Ts.stat(t, function(n, s) {
      r(n, n ? !1 : Is(s, t, e));
    });
  }
  i(Ss, "isexe");
  function dd(t, e) {
    return Is(Ts.statSync(t), t, e);
  }
  i(dd, "sync");
});

// ../node_modules/isexe/mode.js
var Rs = S((xp, js) => {
  js.exports = As;
  As.sync = ud;
  var Ps = require("fs");
  function As(t, e, r) {
    Ps.stat(t, function(n, s) {
      r(n, n ? !1 : Os(s, e));
    });
  }
  i(As, "isexe");
  function ud(t, e) {
    return Os(Ps.statSync(t), e);
  }
  i(ud, "sync");
  function Os(t, e) {
    return t.isFile() && ld(t, e);
  }
  i(Os, "checkStat");
  function ld(t, e) {
    var r = t.mode, n = t.uid, s = t.gid, o = e.uid !== void 0 ? e.uid : process.getuid && process.getuid(), a = e.gid !== void 0 ? e.gid : process.
    getgid && process.getgid(), c = parseInt("100", 8), p = parseInt("010", 8), l = parseInt("001", 8), f = c | p, x = r & l || r & p && s ===
    a || r & c && n === o || r & f && o === 0;
    return x;
  }
  i(ld, "checkMode");
});

// ../node_modules/isexe/index.js
var Zs = S((_p, Ns) => {
  var vp = require("fs"), Mt;
  process.platform === "win32" || global.TESTING_WINDOWS ? Mt = Cs() : Mt = Rs();
  Ns.exports = Sr;
  Sr.sync = pd;
  function Sr(t, e, r) {
    if (typeof e == "function" && (r = e, e = {}), !r) {
      if (typeof Promise != "function")
        throw new TypeError("callback not provided");
      return new Promise(function(n, s) {
        Sr(t, e || {}, function(o, a) {
          o ? s(o) : n(a);
        });
      });
    }
    Mt(t, e || {}, function(n, s) {
      n && (n.code === "EACCES" || e && e.ignoreErrors) && (n = null, s = !1), r(n, s);
    });
  }
  i(Sr, "isexe");
  function pd(t, e) {
    try {
      return Mt.sync(t, e || {});
    } catch (r) {
      if (e && e.ignoreErrors || r.code === "EACCES")
        return !1;
      throw r;
    }
  }
  i(pd, "sync");
});

// ../node_modules/which/which.js
var Fs = S((kp, Vs) => {
  var Ze = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys", Ms = require("path"), fd = Ze ?
  ";" : ":", Ls = Zs(), Ds = /* @__PURE__ */ i((t) => Object.assign(new Error(`not found: ${t}`), { code: "ENOENT" }), "getNotFoundError"), Us = /* @__PURE__ */ i(
  (t, e) => {
    let r = e.colon || fd, n = t.match(/\//) || Ze && t.match(/\\/) ? [""] : [
      // windows always checks the cwd first
      ...Ze ? [process.cwd()] : [],
      ...(e.path || process.env.PATH || /* istanbul ignore next: very unusual */
      "").split(r)
    ], s = Ze ? e.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "", o = Ze ? s.split(r) : [""];
    return Ze && t.indexOf(".") !== -1 && o[0] !== "" && o.unshift(""), {
      pathEnv: n,
      pathExt: o,
      pathExtExe: s
    };
  }, "getPathInfo"), $s = /* @__PURE__ */ i((t, e, r) => {
    typeof e == "function" && (r = e, e = {}), e || (e = {});
    let { pathEnv: n, pathExt: s, pathExtExe: o } = Us(t, e), a = [], c = /* @__PURE__ */ i((l) => new Promise((f, x) => {
      if (l === n.length)
        return e.all && a.length ? f(a) : x(Ds(t));
      let w = n[l], _ = /^".*"$/.test(w) ? w.slice(1, -1) : w, P = Ms.join(_, t), E = !_ && /^\.[\\\/]/.test(t) ? t.slice(0, 2) + P : P;
      f(p(E, l, 0));
    }), "step"), p = /* @__PURE__ */ i((l, f, x) => new Promise((w, _) => {
      if (x === s.length)
        return w(c(f + 1));
      let P = s[x];
      Ls(l + P, { pathExt: o }, (E, A) => {
        if (!E && A)
          if (e.all)
            a.push(l + P);
          else
            return w(l + P);
        return w(p(l, f, x + 1));
      });
    }), "subStep");
    return r ? c(0).then((l) => r(null, l), r) : c(0);
  }, "which"), md = /* @__PURE__ */ i((t, e) => {
    e = e || {};
    let { pathEnv: r, pathExt: n, pathExtExe: s } = Us(t, e), o = [];
    for (let a = 0; a < r.length; a++) {
      let c = r[a], p = /^".*"$/.test(c) ? c.slice(1, -1) : c, l = Ms.join(p, t), f = !p && /^\.[\\\/]/.test(t) ? t.slice(0, 2) + l : l;
      for (let x = 0; x < n.length; x++) {
        let w = f + n[x];
        try {
          if (Ls.sync(w, { pathExt: s }))
            if (e.all)
              o.push(w);
            else
              return w;
        } catch {
        }
      }
    }
    if (e.all && o.length)
      return o;
    if (e.nothrow)
      return null;
    throw Ds(t);
  }, "whichSync");
  Vs.exports = $s;
  $s.sync = md;
});

// ../node_modules/path-key/index.js
var Ws = S((Ip, Er) => {
  "use strict";
  var Bs = /* @__PURE__ */ i((t = {}) => {
    let e = t.env || process.env;
    return (t.platform || process.platform) !== "win32" ? "PATH" : Object.keys(e).reverse().find((n) => n.toUpperCase() === "PATH") || "Path";
  }, "pathKey");
  Er.exports = Bs;
  Er.exports.default = Bs;
});

// ../node_modules/cross-spawn/lib/util/resolveCommand.js
var zs = S((Ep, Ks) => {
  "use strict";
  var qs = require("path"), hd = Fs(), yd = Ws();
  function Gs(t, e) {
    let r = t.options.env || process.env, n = process.cwd(), s = t.options.cwd != null, o = s && process.chdir !== void 0 && !process.chdir.
    disabled;
    if (o)
      try {
        process.chdir(t.options.cwd);
      } catch {
      }
    let a;
    try {
      a = hd.sync(t.command, {
        path: r[yd({ env: r })],
        pathExt: e ? qs.delimiter : void 0
      });
    } catch {
    } finally {
      o && process.chdir(n);
    }
    return a && (a = qs.resolve(s ? t.options.cwd : "", a)), a;
  }
  i(Gs, "resolveCommandAttempt");
  function gd(t) {
    return Gs(t) || Gs(t, !0);
  }
  i(gd, "resolveCommand");
  Ks.exports = gd;
});

// ../node_modules/cross-spawn/lib/util/escape.js
var Js = S((Pp, Pr) => {
  "use strict";
  var Cr = /([()\][%!^"`<>&|;, *?])/g;
  function xd(t) {
    return t = t.replace(Cr, "^$1"), t;
  }
  i(xd, "escapeCommand");
  function bd(t, e) {
    return t = `${t}`, t = t.replace(/(?=(\\+?)?)\1"/g, '$1$1\\"'), t = t.replace(/(?=(\\+?)?)\1$/, "$1$1"), t = `"${t}"`, t = t.replace(Cr,
    "^$1"), e && (t = t.replace(Cr, "^$1")), t;
  }
  i(bd, "escapeArgument");
  Pr.exports.command = xd;
  Pr.exports.argument = bd;
});

// ../node_modules/shebang-regex/index.js
var Hs = S((Op, Ys) => {
  "use strict";
  Ys.exports = /^#!(.*)/;
});

// ../node_modules/shebang-command/index.js
var Qs = S((jp, Xs) => {
  "use strict";
  var vd = Hs();
  Xs.exports = (t = "") => {
    let e = t.match(vd);
    if (!e)
      return null;
    let [r, n] = e[0].replace(/#! ?/, "").split(" "), s = r.split("/").pop();
    return s === "env" ? n : n ? `${s} ${n}` : s;
  };
});

// ../node_modules/cross-spawn/lib/util/readShebang.js
var to = S((Rp, eo) => {
  "use strict";
  var Ar = require("fs"), _d = Qs();
  function wd(t) {
    let r = Buffer.alloc(150), n;
    try {
      n = Ar.openSync(t, "r"), Ar.readSync(n, r, 0, 150, 0), Ar.closeSync(n);
    } catch {
    }
    return _d(r.toString());
  }
  i(wd, "readShebang");
  eo.exports = wd;
});

// ../node_modules/cross-spawn/lib/parse.js
var oo = S((Zp, so) => {
  "use strict";
  var kd = require("path"), ro = zs(), no = Js(), Td = to(), Id = process.platform === "win32", Sd = /\.(?:com|exe)$/i, Ed = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
  function Cd(t) {
    t.file = ro(t);
    let e = t.file && Td(t.file);
    return e ? (t.args.unshift(t.file), t.command = e, ro(t)) : t.file;
  }
  i(Cd, "detectShebang");
  function Pd(t) {
    if (!Id)
      return t;
    let e = Cd(t), r = !Sd.test(e);
    if (t.options.forceShell || r) {
      let n = Ed.test(e);
      t.command = kd.normalize(t.command), t.command = no.command(t.command), t.args = t.args.map((o) => no.argument(o, n));
      let s = [t.command].concat(t.args).join(" ");
      t.args = ["/d", "/s", "/c", `"${s}"`], t.command = process.env.comspec || "cmd.exe", t.options.windowsVerbatimArguments = !0;
    }
    return t;
  }
  i(Pd, "parseNonShell");
  function Ad(t, e, r) {
    e && !Array.isArray(e) && (r = e, e = null), e = e ? e.slice(0) : [], r = Object.assign({}, r);
    let n = {
      command: t,
      args: e,
      options: r,
      file: void 0,
      original: {
        command: t,
        args: e
      }
    };
    return r.shell ? n : Pd(n);
  }
  i(Ad, "parse");
  so.exports = Ad;
});

// ../node_modules/cross-spawn/lib/enoent.js
var co = S((Lp, ao) => {
  "use strict";
  var Or = process.platform === "win32";
  function jr(t, e) {
    return Object.assign(new Error(`${e} ${t.command} ENOENT`), {
      code: "ENOENT",
      errno: "ENOENT",
      syscall: `${e} ${t.command}`,
      path: t.command,
      spawnargs: t.args
    });
  }
  i(jr, "notFoundError");
  function Od(t, e) {
    if (!Or)
      return;
    let r = t.emit;
    t.emit = function(n, s) {
      if (n === "exit") {
        let o = io(s, e);
        if (o)
          return r.call(t, "error", o);
      }
      return r.apply(t, arguments);
    };
  }
  i(Od, "hookChildProcess");
  function io(t, e) {
    return Or && t === 1 && !e.file ? jr(e.original, "spawn") : null;
  }
  i(io, "verifyENOENT");
  function jd(t, e) {
    return Or && t === 1 && !e.file ? jr(e.original, "spawnSync") : null;
  }
  i(jd, "verifyENOENTSync");
  ao.exports = {
    hookChildProcess: Od,
    verifyENOENT: io,
    verifyENOENTSync: jd,
    notFoundError: jr
  };
});

// ../node_modules/cross-spawn/index.js
var po = S((Up, Me) => {
  "use strict";
  var uo = require("child_process"), Rr = oo(), Nr = co();
  function lo(t, e, r) {
    let n = Rr(t, e, r), s = uo.spawn(n.command, n.args, n.options);
    return Nr.hookChildProcess(s, n), s;
  }
  i(lo, "spawn");
  function Rd(t, e, r) {
    let n = Rr(t, e, r), s = uo.spawnSync(n.command, n.args, n.options);
    return s.error = s.error || Nr.verifyENOENTSync(s.status, n), s;
  }
  i(Rd, "spawnSync");
  Me.exports = lo;
  Me.exports.spawn = lo;
  Me.exports.sync = Rd;
  Me.exports._parse = Rr;
  Me.exports._enoent = Nr;
});

// ../node_modules/merge-stream/index.js
var Wo = S((nm, Bo) => {
  "use strict";
  var { PassThrough: Iu } = require("stream");
  Bo.exports = function() {
    var t = [], e = new Iu({ objectMode: !0 });
    return e.setMaxListeners(0), e.add = r, e.isEmpty = n, e.on("unpipe", s), Array.prototype.slice.call(arguments).forEach(r), e;
    function r(o) {
      return Array.isArray(o) ? (o.forEach(r), this) : (t.push(o), o.once("end", s.bind(null, o)), o.once("error", e.emit.bind(e, "error")),
      o.pipe(e, { end: !1 }), this);
    }
    i(r, "add");
    function n() {
      return t.length == 0;
    }
    i(n, "isEmpty");
    function s(o) {
      t = t.filter(function(a) {
        return a !== o;
      }), !t.length && e.readable && e.end();
    }
    i(s, "remove");
  };
});

// ../node_modules/slash/index.js
function an(t) {
  return t.startsWith("\\\\?\\") ? t : t.replace(/\\/g, "/");
}
var gi = jn(() => {
  i(an, "slash");
});

// ../node_modules/common-path-prefix/index.js
var vi = S((Lm, bi) => {
  "use strict";
  var { sep: Uu } = require("path"), $u = /* @__PURE__ */ i((t) => {
    for (let e of t) {
      let r = /(\/|\\)/.exec(e);
      if (r !== null) return r[0];
    }
    return Uu;
  }, "determineSeparator");
  bi.exports = /* @__PURE__ */ i(function(e, r = $u(e)) {
    let [n = "", ...s] = e;
    if (n === "" || s.length === 0) return "";
    let o = n.split(r), a = o.length;
    for (let p of s) {
      let l = p.split(r);
      for (let f = 0; f < a; f++)
        l[f] !== o[f] && (a = f);
      if (a === 0) return "";
    }
    let c = o.slice(0, a).join(r);
    return c.endsWith(r) ? c : c + r;
  }, "commonPathPrefix");
});

// ../node_modules/yocto-queue/index.js
var dn, at, _i = jn(() => {
  dn = class {
    static {
      i(this, "Node");
    }
    value;
    next;
    constructor(e) {
      this.value = e;
    }
  }, at = class {
    static {
      i(this, "Queue");
    }
    #r;
    #t;
    #e;
    constructor() {
      this.clear();
    }
    enqueue(e) {
      let r = new dn(e);
      this.#r ? (this.#t.next = r, this.#t = r) : (this.#r = r, this.#t = r), this.#e++;
    }
    dequeue() {
      let e = this.#r;
      if (e)
        return this.#r = this.#r.next, this.#e--, e.value;
    }
    peek() {
      if (this.#r)
        return this.#r.value;
    }
    clear() {
      this.#r = void 0, this.#t = void 0, this.#e = 0;
    }
    get size() {
      return this.#e;
    }
    *[Symbol.iterator]() {
      let e = this.#r;
      for (; e; )
        yield e.value, e = e.next;
    }
    *drain() {
      for (; this.#r; )
        yield this.dequeue();
    }
  };
});

// ../node_modules/fetch-retry/index.js
var ua = S((_g, da) => {
  "use strict";
  da.exports = function(t, e) {
    if (e = e || {}, typeof t != "function")
      throw new se("fetch must be a function");
    if (typeof e != "object")
      throw new se("defaults must be an object");
    if (e.retries !== void 0 && !cr(e.retries))
      throw new se("retries must be a positive integer");
    if (e.retryDelay !== void 0 && !cr(e.retryDelay) && typeof e.retryDelay != "function")
      throw new se("retryDelay must be a positive integer or a function returning a positive integer");
    if (e.retryOn !== void 0 && !Array.isArray(e.retryOn) && typeof e.retryOn != "function")
      throw new se("retryOn property expects an array or function");
    var r = {
      retries: 3,
      retryDelay: 1e3,
      retryOn: []
    };
    return e = Object.assign(r, e), /* @__PURE__ */ i(function(s, o) {
      var a = e.retries, c = e.retryDelay, p = e.retryOn;
      if (o && o.retries !== void 0)
        if (cr(o.retries))
          a = o.retries;
        else
          throw new se("retries must be a positive integer");
      if (o && o.retryDelay !== void 0)
        if (cr(o.retryDelay) || typeof o.retryDelay == "function")
          c = o.retryDelay;
        else
          throw new se("retryDelay must be a positive integer or a function returning a positive integer");
      if (o && o.retryOn)
        if (Array.isArray(o.retryOn) || typeof o.retryOn == "function")
          p = o.retryOn;
        else
          throw new se("retryOn property expects an array or function");
      return new Promise(function(l, f) {
        var x = /* @__PURE__ */ i(function(_) {
          var P = typeof Request < "u" && s instanceof Request ? s.clone() : s;
          t(P, o).then(function(E) {
            if (Array.isArray(p) && p.indexOf(E.status) === -1)
              l(E);
            else if (typeof p == "function")
              try {
                return Promise.resolve(p(_, null, E)).then(function(A) {
                  A ? w(_, null, E) : l(E);
                }).catch(f);
              } catch (A) {
                f(A);
              }
            else
              _ < a ? w(_, null, E) : l(E);
          }).catch(function(E) {
            if (typeof p == "function")
              try {
                Promise.resolve(p(_, E, null)).then(function(A) {
                  A ? w(_, E, null) : f(E);
                }).catch(function(A) {
                  f(A);
                });
              } catch (A) {
                f(A);
              }
            else _ < a ? w(_, E, null) : f(E);
          });
        }, "wrappedFetch");
        function w(_, P, E) {
          var A = typeof c == "function" ? c(_, P, E) : c;
          setTimeout(function() {
            x(++_);
          }, A);
        }
        i(w, "retry"), x(0);
      });
    }, "fetchRetry");
  };
  function cr(t) {
    return Number.isInteger(t) && t >= 0;
  }
  i(cr, "isPositiveInteger");
  function se(t) {
    this.name = "ArgumentError", this.message = t;
  }
  i(se, "ArgumentError");
});

// src/telemetry/index.ts
var Pl = {};
Aa(Pl, {
  addToGlobalContext: () => ka,
  cleanPaths: () => Ie,
  computeStorybookMetadata: () => ca,
  getPrecedingUpgrade: () => ba,
  getStorybookMetadata: () => In,
  isExampleStoryId: () => El,
  metaFrameworks: () => kn,
  oneWayHash: () => dr,
  removeAnsiEscapeCodes: () => hr,
  sanitizeAddonName: () => Tn,
  sanitizeError: () => Ge,
  telemetry: () => Cl
});
module.exports = Oa(Pl);
var On = require("storybook/internal/node-logger");

// src/telemetry/notify.ts
var mr = require("storybook/internal/common"), oe = require("storybook/internal/node-logger"), Dn = T(Mn(), 1);
var Ln = "telemetry-notification-date", Un = /* @__PURE__ */ i(async () => {
  await mr.cache.get(Ln, null) || (mr.cache.set(Ln, Date.now()), oe.logger.log(
    `${oe.CLI_COLORS.info("Attention:")} Storybook now collects completely anonymous telemetry regarding usage. This information is used to \
shape Storybook's roadmap and prioritize features.`
  ), oe.logger.log(
    "You can learn more, including how to opt-out if you'd not like to participate in this anonymous program, by visiting the following URL:"
  ), oe.logger.log(Dn.default.cyan("https://storybook.js.org/telemetry")), oe.logger.log(""));
}, "notify");

// src/telemetry/sanitize.ts
var yr = T(require("node:path"), 1);
function $n(t) {
  return t.replace(/[-[/{}()*+?.\\^$|]/g, "\\$&");
}
i($n, "regexpEscape");
function hr(t = "") {
  return t.replace(/\u001B\[[0-9;]*m/g, "");
}
i(hr, "removeAnsiEscapeCodes");
function Ie(t, e = yr.default.sep) {
  if (!t)
    return t;
  let r = process.cwd().split(e);
  for (; r.length > 1; ) {
    let n = r.join(e), s = new RegExp($n(n), "gi");
    t = t.replace(s, "$SNIP");
    let o = r.join(e + e), a = new RegExp($n(o), "gi");
    t = t.replace(a, "$SNIP"), r.pop();
  }
  return t;
}
i(Ie, "cleanPaths");
function Ge(t, e = yr.default.sep) {
  try {
    t = {
      ...JSON.parse(JSON.stringify(t)),
      message: hr(t.message),
      stack: hr(t.stack),
      cause: t.cause,
      name: t.name
    };
    let r = Ie(JSON.stringify(t), e);
    return JSON.parse(r);
  } catch (r) {
    return `Sanitization error: ${r?.message}`;
  }
}
i(Ge, "sanitizeError");

// src/telemetry/storybook-metadata.ts
var ia = require("node:path"), ne = require("storybook/internal/common"), aa = require("storybook/internal/csf-tools");

// ../node_modules/fd-package-json/dist/esm/main.js
var Bn = T(Fn(), 1), Wn = require("node:path"), _t = require("node:fs/promises"), qn = require("node:fs");
async function Ma(t) {
  try {
    return (await (0, _t.stat)(t)).isFile();
  } catch {
    return !1;
  }
}
i(Ma, "fileExists");
async function gr(t) {
  for (let e of (0, Bn.walkUp)(t)) {
    let r = (0, Wn.resolve)(e, "package.json");
    if (await Ma(r))
      return r;
  }
  return null;
}
i(gr, "findPackagePath");
async function Gn(t) {
  let e = await gr(t);
  if (!e)
    return null;
  try {
    let r = await (0, _t.readFile)(e, { encoding: "utf8" });
    return JSON.parse(r);
  } catch {
    return null;
  }
}
i(Gn, "findPackage");

// package.json
var wt = "9.1.0";

// src/cli/globalSettings.ts
var Rt = T(require("node:fs/promises"), 1), ws = require("node:os"), Zt = require("node:path"), Ne = T(gs(), 1);

// src/server-errors.ts
var _s = T(bs(), 1);

// src/storybook-error.ts
function vs({
  code: t,
  category: e
}) {
  let r = String(t).padStart(4, "0");
  return `SB_${e}_${r}`;
}
i(vs, "parseErrorCode");
var Ot = class t extends Error {
  constructor(r) {
    super(t.getFullMessage(r));
    /**
     * Data associated with the error. Used to provide additional information in the error message or
     * to be passed to telemetry.
     */
    this.data = {};
    /** Flag used to easily determine if the error originates from Storybook. */
    this.fromStorybook = !0;
    this.category = r.category, this.documentation = r.documentation ?? !1, this.code = r.code;
  }
  static {
    i(this, "StorybookError");
  }
  get fullErrorCode() {
    return vs({ code: this.code, category: this.category });
  }
  /** Overrides the default `Error.name` property in the format: SB_<CATEGORY>_<CODE>. */
  get name() {
    let r = this.constructor.name;
    return `${this.fullErrorCode} (${r})`;
  }
  /** Generates the error message along with additional documentation link (if applicable). */
  static getFullMessage({
    documentation: r,
    code: n,
    category: s,
    message: o
  }) {
    let a;
    return r === !0 ? a = `https://storybook.js.org/error/${vs({ code: n, category: s })}` : typeof r == "string" ? a = r : Array.isArray(r) &&
    (a = `
${r.map((c) => `	- ${c}`).join(`
`)}`), `${o}${a != null ? `

More info: ${a}
` : ""}`;
  }
};

// src/server-errors.ts
var jt = class extends Ot {
  constructor(r) {
    super({
      category: "CORE-SERVER",
      code: 1,
      message: _s.dedent`
        Unable to save global settings file to ${r.filePath}
        ${r.error && `Reason: ${r.error}`}`
    });
    this.data = r;
  }
  static {
    i(this, "SavingGlobalSettingsFileError");
  }
};

// src/cli/globalSettings.ts
var od = (0, Zt.join)((0, ws.homedir)(), ".storybook", "settings.json"), id = 1, ad = Ne.z.object({
  version: Ne.z.number(),
  // NOTE: every key (and subkey) below must be optional, for forwards compatibility reasons
  // (we can remove keys once they are deprecated)
  userSince: Ne.z.number().optional(),
  init: Ne.z.object({ skipOnboarding: Ne.z.boolean().optional() }).optional()
}), Re;
async function ks(t = od) {
  if (Re)
    return Re;
  try {
    let e = await Rt.default.readFile(t, "utf8"), r = ad.parse(JSON.parse(e));
    Re = new Nt(t, r);
  } catch {
    Re = new Nt(t, { version: id, userSince: Date.now() }), await Re.save();
  }
  return Re;
}
i(ks, "globalSettings");
var Nt = class {
  static {
    i(this, "Settings");
  }
  /**
   * Create a new Settings instance
   *
   * @param filePath Path to the JSON settings file
   * @param value Loaded value of settings
   */
  constructor(e, r) {
    this.filePath = e, this.value = r;
  }
  /** Save settings to the file */
  async save() {
    try {
      await Rt.default.mkdir((0, Zt.dirname)(this.filePath), { recursive: !0 }), await Rt.default.writeFile(this.filePath, JSON.stringify(this.
      value, null, 2));
    } catch (e) {
      throw new jt({
        filePath: this.filePath,
        error: e
      });
    }
  }
};

// src/telemetry/get-application-file-count.ts
var Bi = require("node:path");

// src/telemetry/exec-command-count-lines.ts
var yi = require("node:readline");

// node_modules/execa/index.js
var ui = require("node:buffer"), li = T(require("node:path"), 1), Yt = T(require("node:child_process"), 1), nt = T(require("node:process"), 1),
pi = T(po(), 1);

// ../node_modules/strip-final-newline/index.js
function Zr(t) {
  let e = typeof t == "string" ? `
` : 10, r = typeof t == "string" ? "\r" : 13;
  return t[t.length - 1] === e && (t = t.slice(0, -1)), t[t.length - 1] === r && (t = t.slice(0, -1)), t;
}
i(Zr, "stripFinalNewline");

// node_modules/npm-run-path/index.js
var et = T(require("node:process"), 1), Le = T(require("node:path"), 1), Mr = require("node:url");

// node_modules/path-key/index.js
function Lt(t = {}) {
  let {
    env: e = process.env,
    platform: r = process.platform
  } = t;
  return r !== "win32" ? "PATH" : Object.keys(e).reverse().find((n) => n.toUpperCase() === "PATH") || "Path";
}
i(Lt, "pathKey");

// node_modules/npm-run-path/index.js
var Nd = /* @__PURE__ */ i(({
  cwd: t = et.default.cwd(),
  path: e = et.default.env[Lt()],
  preferLocal: r = !0,
  execPath: n = et.default.execPath,
  addExecPath: s = !0
} = {}) => {
  let o = t instanceof URL ? (0, Mr.fileURLToPath)(t) : t, a = Le.default.resolve(o), c = [];
  return r && Zd(c, a), s && Md(c, n, a), [...c, e].join(Le.default.delimiter);
}, "npmRunPath"), Zd = /* @__PURE__ */ i((t, e) => {
  let r;
  for (; r !== e; )
    t.push(Le.default.join(e, "node_modules/.bin")), r = e, e = Le.default.resolve(e, "..");
}, "applyPreferLocal"), Md = /* @__PURE__ */ i((t, e, r) => {
  let n = e instanceof URL ? (0, Mr.fileURLToPath)(e) : e;
  t.push(Le.default.resolve(r, n, ".."));
}, "applyExecPath"), fo = /* @__PURE__ */ i(({ env: t = et.default.env, ...e } = {}) => {
  t = { ...t };
  let r = Lt({ env: t });
  return e.path = t[r], t[r] = Nd(e), t;
}, "npmRunPathEnv");

// node_modules/mimic-fn/index.js
var Ld = /* @__PURE__ */ i((t, e, r, n) => {
  if (r === "length" || r === "prototype" || r === "arguments" || r === "caller")
    return;
  let s = Object.getOwnPropertyDescriptor(t, r), o = Object.getOwnPropertyDescriptor(e, r);
  !Dd(s, o) && n || Object.defineProperty(t, r, o);
}, "copyProperty"), Dd = /* @__PURE__ */ i(function(t, e) {
  return t === void 0 || t.configurable || t.writable === e.writable && t.enumerable === e.enumerable && t.configurable === e.configurable &&
  (t.writable || t.value === e.value);
}, "canCopyProperty"), Ud = /* @__PURE__ */ i((t, e) => {
  let r = Object.getPrototypeOf(e);
  r !== Object.getPrototypeOf(t) && Object.setPrototypeOf(t, r);
}, "changePrototype"), $d = /* @__PURE__ */ i((t, e) => `/* Wrapped ${t}*/
${e}`, "wrappedToString"), Vd = Object.getOwnPropertyDescriptor(Function.prototype, "toString"), Fd = Object.getOwnPropertyDescriptor(Function.
prototype.toString, "name"), Bd = /* @__PURE__ */ i((t, e, r) => {
  let n = r === "" ? "" : `with ${r.trim()}() `, s = $d.bind(null, n, e.toString());
  Object.defineProperty(s, "name", Fd), Object.defineProperty(t, "toString", { ...Vd, value: s });
}, "changeToString");
function Lr(t, e, { ignoreNonConfigurable: r = !1 } = {}) {
  let { name: n } = t;
  for (let s of Reflect.ownKeys(e))
    Ld(t, e, s, r);
  return Ud(t, e), Bd(t, e, n), t;
}
i(Lr, "mimicFunction");

// node_modules/onetime/index.js
var Dt = /* @__PURE__ */ new WeakMap(), mo = /* @__PURE__ */ i((t, e = {}) => {
  if (typeof t != "function")
    throw new TypeError("Expected a function");
  let r, n = 0, s = t.displayName || t.name || "<anonymous>", o = /* @__PURE__ */ i(function(...a) {
    if (Dt.set(o, ++n), n === 1)
      r = t.apply(this, a), t = null;
    else if (e.throw === !0)
      throw new Error(`Function \`${s}\` can only be called once`);
    return r;
  }, "onetime");
  return Lr(o, t), Dt.set(o, n), o;
}, "onetime");
mo.callCount = (t) => {
  if (!Dt.has(t))
    throw new Error(`The given function \`${t.name}\` is not wrapped by the \`onetime\` package`);
  return Dt.get(t);
};
var ho = mo;

// node_modules/execa/lib/error.js
var wo = T(require("node:process"), 1);

// node_modules/human-signals/build/src/main.js
var vo = require("node:os");

// node_modules/human-signals/build/src/realtime.js
var yo = /* @__PURE__ */ i(() => {
  let t = Dr - go + 1;
  return Array.from({ length: t }, Wd);
}, "getRealtimeSignals"), Wd = /* @__PURE__ */ i((t, e) => ({
  name: `SIGRT${e + 1}`,
  number: go + e,
  action: "terminate",
  description: "Application-specific signal (realtime)",
  standard: "posix"
}), "getRealtimeSignal"), go = 34, Dr = 64;

// node_modules/human-signals/build/src/signals.js
var bo = require("node:os");

// node_modules/human-signals/build/src/core.js
var xo = [
  {
    name: "SIGHUP",
    number: 1,
    action: "terminate",
    description: "Terminal closed",
    standard: "posix"
  },
  {
    name: "SIGINT",
    number: 2,
    action: "terminate",
    description: "User interruption with CTRL-C",
    standard: "ansi"
  },
  {
    name: "SIGQUIT",
    number: 3,
    action: "core",
    description: "User interruption with CTRL-\\",
    standard: "posix"
  },
  {
    name: "SIGILL",
    number: 4,
    action: "core",
    description: "Invalid machine instruction",
    standard: "ansi"
  },
  {
    name: "SIGTRAP",
    number: 5,
    action: "core",
    description: "Debugger breakpoint",
    standard: "posix"
  },
  {
    name: "SIGABRT",
    number: 6,
    action: "core",
    description: "Aborted",
    standard: "ansi"
  },
  {
    name: "SIGIOT",
    number: 6,
    action: "core",
    description: "Aborted",
    standard: "bsd"
  },
  {
    name: "SIGBUS",
    number: 7,
    action: "core",
    description: "Bus error due to misaligned, non-existing address or paging error",
    standard: "bsd"
  },
  {
    name: "SIGEMT",
    number: 7,
    action: "terminate",
    description: "Command should be emulated but is not implemented",
    standard: "other"
  },
  {
    name: "SIGFPE",
    number: 8,
    action: "core",
    description: "Floating point arithmetic error",
    standard: "ansi"
  },
  {
    name: "SIGKILL",
    number: 9,
    action: "terminate",
    description: "Forced termination",
    standard: "posix",
    forced: !0
  },
  {
    name: "SIGUSR1",
    number: 10,
    action: "terminate",
    description: "Application-specific signal",
    standard: "posix"
  },
  {
    name: "SIGSEGV",
    number: 11,
    action: "core",
    description: "Segmentation fault",
    standard: "ansi"
  },
  {
    name: "SIGUSR2",
    number: 12,
    action: "terminate",
    description: "Application-specific signal",
    standard: "posix"
  },
  {
    name: "SIGPIPE",
    number: 13,
    action: "terminate",
    description: "Broken pipe or socket",
    standard: "posix"
  },
  {
    name: "SIGALRM",
    number: 14,
    action: "terminate",
    description: "Timeout or timer",
    standard: "posix"
  },
  {
    name: "SIGTERM",
    number: 15,
    action: "terminate",
    description: "Termination",
    standard: "ansi"
  },
  {
    name: "SIGSTKFLT",
    number: 16,
    action: "terminate",
    description: "Stack is empty or overflowed",
    standard: "other"
  },
  {
    name: "SIGCHLD",
    number: 17,
    action: "ignore",
    description: "Child process terminated, paused or unpaused",
    standard: "posix"
  },
  {
    name: "SIGCLD",
    number: 17,
    action: "ignore",
    description: "Child process terminated, paused or unpaused",
    standard: "other"
  },
  {
    name: "SIGCONT",
    number: 18,
    action: "unpause",
    description: "Unpaused",
    standard: "posix",
    forced: !0
  },
  {
    name: "SIGSTOP",
    number: 19,
    action: "pause",
    description: "Paused",
    standard: "posix",
    forced: !0
  },
  {
    name: "SIGTSTP",
    number: 20,
    action: "pause",
    description: 'Paused using CTRL-Z or "suspend"',
    standard: "posix"
  },
  {
    name: "SIGTTIN",
    number: 21,
    action: "pause",
    description: "Background process cannot read terminal input",
    standard: "posix"
  },
  {
    name: "SIGBREAK",
    number: 21,
    action: "terminate",
    description: "User interruption with CTRL-BREAK",
    standard: "other"
  },
  {
    name: "SIGTTOU",
    number: 22,
    action: "pause",
    description: "Background process cannot write to terminal output",
    standard: "posix"
  },
  {
    name: "SIGURG",
    number: 23,
    action: "ignore",
    description: "Socket received out-of-band data",
    standard: "bsd"
  },
  {
    name: "SIGXCPU",
    number: 24,
    action: "core",
    description: "Process timed out",
    standard: "bsd"
  },
  {
    name: "SIGXFSZ",
    number: 25,
    action: "core",
    description: "File too big",
    standard: "bsd"
  },
  {
    name: "SIGVTALRM",
    number: 26,
    action: "terminate",
    description: "Timeout or timer",
    standard: "bsd"
  },
  {
    name: "SIGPROF",
    number: 27,
    action: "terminate",
    description: "Timeout or timer",
    standard: "bsd"
  },
  {
    name: "SIGWINCH",
    number: 28,
    action: "ignore",
    description: "Terminal window size changed",
    standard: "bsd"
  },
  {
    name: "SIGIO",
    number: 29,
    action: "terminate",
    description: "I/O is available",
    standard: "other"
  },
  {
    name: "SIGPOLL",
    number: 29,
    action: "terminate",
    description: "Watched event",
    standard: "other"
  },
  {
    name: "SIGINFO",
    number: 29,
    action: "ignore",
    description: "Request for process information",
    standard: "other"
  },
  {
    name: "SIGPWR",
    number: 30,
    action: "terminate",
    description: "Device running out of power",
    standard: "systemv"
  },
  {
    name: "SIGSYS",
    number: 31,
    action: "core",
    description: "Invalid system call",
    standard: "other"
  },
  {
    name: "SIGUNUSED",
    number: 31,
    action: "terminate",
    description: "Invalid system call",
    standard: "other"
  }
];

// node_modules/human-signals/build/src/signals.js
var Ur = /* @__PURE__ */ i(() => {
  let t = yo();
  return [...xo, ...t].map(qd);
}, "getSignals"), qd = /* @__PURE__ */ i(({
  name: t,
  number: e,
  description: r,
  action: n,
  forced: s = !1,
  standard: o
}) => {
  let {
    signals: { [t]: a }
  } = bo.constants, c = a !== void 0;
  return { name: t, number: c ? a : e, description: r, supported: c, action: n, forced: s, standard: o };
}, "normalizeSignal");

// node_modules/human-signals/build/src/main.js
var Gd = /* @__PURE__ */ i(() => {
  let t = Ur();
  return Object.fromEntries(t.map(Kd));
}, "getSignalsByName"), Kd = /* @__PURE__ */ i(({
  name: t,
  number: e,
  description: r,
  supported: n,
  action: s,
  forced: o,
  standard: a
}) => [t, { name: t, number: e, description: r, supported: n, action: s, forced: o, standard: a }], "getSignalByName"), _o = Gd(), zd = /* @__PURE__ */ i(
() => {
  let t = Ur(), e = Dr + 1, r = Array.from(
    { length: e },
    (n, s) => Jd(s, t)
  );
  return Object.assign({}, ...r);
}, "getSignalsByNumber"), Jd = /* @__PURE__ */ i((t, e) => {
  let r = Yd(t, e);
  if (r === void 0)
    return {};
  let { name: n, description: s, supported: o, action: a, forced: c, standard: p } = r;
  return {
    [t]: {
      name: n,
      number: t,
      description: s,
      supported: o,
      action: a,
      forced: c,
      standard: p
    }
  };
}, "getSignalByNumber"), Yd = /* @__PURE__ */ i((t, e) => {
  let r = e.find(({ name: n }) => vo.constants.signals[n] === t);
  return r !== void 0 ? r : e.find((n) => n.number === t);
}, "findSignalByNumber"), df = zd();

// node_modules/execa/lib/error.js
var Hd = /* @__PURE__ */ i(({ timedOut: t, timeout: e, errorCode: r, signal: n, signalDescription: s, exitCode: o, isCanceled: a }) => t ? `\
timed out after ${e} milliseconds` : a ? "was canceled" : r !== void 0 ? `failed with ${r}` : n !== void 0 ? `was killed with ${n} (${s})` :
o !== void 0 ? `failed with exit code ${o}` : "failed", "getErrorPrefix"), tt = /* @__PURE__ */ i(({
  stdout: t,
  stderr: e,
  all: r,
  error: n,
  signal: s,
  exitCode: o,
  command: a,
  escapedCommand: c,
  timedOut: p,
  isCanceled: l,
  killed: f,
  parsed: { options: { timeout: x, cwd: w = wo.default.cwd() } }
}) => {
  o = o === null ? void 0 : o, s = s === null ? void 0 : s;
  let _ = s === void 0 ? void 0 : _o[s].description, P = n && n.code, A = `Command ${Hd({ timedOut: p, timeout: x, errorCode: P, signal: s, signalDescription: _,
  exitCode: o, isCanceled: l })}: ${a}`, W = Object.prototype.toString.call(n) === "[object Error]", Be = W ? `${A}
${n.message}` : A, Te = [Be, e, t].filter(Boolean).join(`
`);
  return W ? (n.originalMessage = n.message, n.message = Te) : n = new Error(Te), n.shortMessage = Be, n.command = a, n.escapedCommand = c, n.
  exitCode = o, n.signal = s, n.signalDescription = _, n.stdout = t, n.stderr = e, n.cwd = w, r !== void 0 && (n.all = r), "bufferedData" in
  n && delete n.bufferedData, n.failed = !0, n.timedOut = !!p, n.isCanceled = l, n.killed = f && !p, n;
}, "makeError");

// node_modules/execa/lib/stdio.js
var Ut = ["stdin", "stdout", "stderr"], Xd = /* @__PURE__ */ i((t) => Ut.some((e) => t[e] !== void 0), "hasAlias"), ko = /* @__PURE__ */ i((t) => {
  if (!t)
    return;
  let { stdio: e } = t;
  if (e === void 0)
    return Ut.map((n) => t[n]);
  if (Xd(t))
    throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${Ut.map((n) => `\`${n}\``).join(", ")}`);
  if (typeof e == "string")
    return e;
  if (!Array.isArray(e))
    throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof e}\``);
  let r = Math.max(e.length, Ut.length);
  return Array.from({ length: r }, (n, s) => e[s]);
}, "normalizeStdio");

// node_modules/execa/lib/kill.js
var Io = T(require("node:os"), 1);

// node_modules/signal-exit/dist/mjs/signals.js
var we = [];
we.push("SIGHUP", "SIGINT", "SIGTERM");
process.platform !== "win32" && we.push(
  "SIGALRM",
  "SIGABRT",
  "SIGVTALRM",
  "SIGXCPU",
  "SIGXFSZ",
  "SIGUSR2",
  "SIGTRAP",
  "SIGSYS",
  "SIGQUIT",
  "SIGIOT"
  // should detect profiler and enable/disable accordingly.
  // see #21
  // 'SIGPROF'
);
process.platform === "linux" && we.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT");

// node_modules/signal-exit/dist/mjs/index.js
var $t = /* @__PURE__ */ i((t) => !!t && typeof t == "object" && typeof t.removeListener == "function" && typeof t.emit == "function" && typeof t.
reallyExit == "function" && typeof t.listeners == "function" && typeof t.kill == "function" && typeof t.pid == "number" && typeof t.on == "f\
unction", "processOk"), $r = Symbol.for("signal-exit emitter"), Vr = globalThis, Qd = Object.defineProperty.bind(Object), Fr = class {
  static {
    i(this, "Emitter");
  }
  emitted = {
    afterExit: !1,
    exit: !1
  };
  listeners = {
    afterExit: [],
    exit: []
  };
  count = 0;
  id = Math.random();
  constructor() {
    if (Vr[$r])
      return Vr[$r];
    Qd(Vr, $r, {
      value: this,
      writable: !1,
      enumerable: !1,
      configurable: !1
    });
  }
  on(e, r) {
    this.listeners[e].push(r);
  }
  removeListener(e, r) {
    let n = this.listeners[e], s = n.indexOf(r);
    s !== -1 && (s === 0 && n.length === 1 ? n.length = 0 : n.splice(s, 1));
  }
  emit(e, r, n) {
    if (this.emitted[e])
      return !1;
    this.emitted[e] = !0;
    let s = !1;
    for (let o of this.listeners[e])
      s = o(r, n) === !0 || s;
    return e === "exit" && (s = this.emit("afterExit", r, n) || s), s;
  }
}, Vt = class {
  static {
    i(this, "SignalExitBase");
  }
}, eu = /* @__PURE__ */ i((t) => ({
  onExit(e, r) {
    return t.onExit(e, r);
  },
  load() {
    return t.load();
  },
  unload() {
    return t.unload();
  }
}), "signalExitWrap"), Br = class extends Vt {
  static {
    i(this, "SignalExitFallback");
  }
  onExit() {
    return () => {
    };
  }
  load() {
  }
  unload() {
  }
}, Wr = class extends Vt {
  static {
    i(this, "SignalExit");
  }
  // "SIGHUP" throws an `ENOSYS` error on Windows,
  // so use a supported signal instead
  /* c8 ignore start */
  #r = qr.platform === "win32" ? "SIGINT" : "SIGHUP";
  /* c8 ignore stop */
  #t = new Fr();
  #e;
  #o;
  #i;
  #s = {};
  #n = !1;
  constructor(e) {
    super(), this.#e = e, this.#s = {};
    for (let r of we)
      this.#s[r] = () => {
        let n = this.#e.listeners(r), { count: s } = this.#t, o = e;
        if (typeof o.__signal_exit_emitter__ == "object" && typeof o.__signal_exit_emitter__.count == "number" && (s += o.__signal_exit_emitter__.
        count), n.length === s) {
          this.unload();
          let a = this.#t.emit("exit", null, r), c = r === "SIGHUP" ? this.#r : r;
          a || e.kill(e.pid, c);
        }
      };
    this.#i = e.reallyExit, this.#o = e.emit;
  }
  onExit(e, r) {
    if (!$t(this.#e))
      return () => {
      };
    this.#n === !1 && this.load();
    let n = r?.alwaysLast ? "afterExit" : "exit";
    return this.#t.on(n, e), () => {
      this.#t.removeListener(n, e), this.#t.listeners.exit.length === 0 && this.#t.listeners.afterExit.length === 0 && this.unload();
    };
  }
  load() {
    if (!this.#n) {
      this.#n = !0, this.#t.count += 1;
      for (let e of we)
        try {
          let r = this.#s[e];
          r && this.#e.on(e, r);
        } catch {
        }
      this.#e.emit = (e, ...r) => this.#c(e, ...r), this.#e.reallyExit = (e) => this.#a(e);
    }
  }
  unload() {
    this.#n && (this.#n = !1, we.forEach((e) => {
      let r = this.#s[e];
      if (!r)
        throw new Error("Listener not defined for signal: " + e);
      try {
        this.#e.removeListener(e, r);
      } catch {
      }
    }), this.#e.emit = this.#o, this.#e.reallyExit = this.#i, this.#t.count -= 1);
  }
  #a(e) {
    return $t(this.#e) ? (this.#e.exitCode = e || 0, this.#t.emit("exit", this.#e.exitCode, null), this.#i.call(this.#e, this.#e.exitCode)) :
    0;
  }
  #c(e, ...r) {
    let n = this.#o;
    if (e === "exit" && $t(this.#e)) {
      typeof r[0] == "number" && (this.#e.exitCode = r[0]);
      let s = n.call(this.#e, e, ...r);
      return this.#t.emit("exit", this.#e.exitCode, null), s;
    } else
      return n.call(this.#e, e, ...r);
  }
}, qr = globalThis.process, {
  /**
   * Called when the process is exiting, whether via signal, explicit
   * exit, or running out of stuff to do.
   *
   * If the global process object is not suitable for instrumentation,
   * then this will be a no-op.
   *
   * Returns a function that may be used to unload signal-exit.
   */
  onExit: To,
  /**
   * Load the listeners.  Likely you never need to call this, unless
   * doing a rather deep integration with signal-exit functionality.
   * Mostly exposed for the benefit of testing.
   *
   * @internal
   */
  load: bf,
  /**
   * Unload the listeners.  Likely you never need to call this, unless
   * doing a rather deep integration with signal-exit functionality.
   * Mostly exposed for the benefit of testing.
   *
   * @internal
   */
  unload: vf
} = eu($t(qr) ? new Wr(qr) : new Br());

// node_modules/execa/lib/kill.js
var tu = 1e3 * 5, So = /* @__PURE__ */ i((t, e = "SIGTERM", r = {}) => {
  let n = t(e);
  return ru(t, e, r, n), n;
}, "spawnedKill"), ru = /* @__PURE__ */ i((t, e, r, n) => {
  if (!nu(e, r, n))
    return;
  let s = ou(r), o = setTimeout(() => {
    t("SIGKILL");
  }, s);
  o.unref && o.unref();
}, "setKillTimeout"), nu = /* @__PURE__ */ i((t, { forceKillAfterTimeout: e }, r) => su(t) && e !== !1 && r, "shouldForceKill"), su = /* @__PURE__ */ i(
(t) => t === Io.default.constants.signals.SIGTERM || typeof t == "string" && t.toUpperCase() === "SIGTERM", "isSigterm"), ou = /* @__PURE__ */ i(
({ forceKillAfterTimeout: t = !0 }) => {
  if (t === !0)
    return tu;
  if (!Number.isFinite(t) || t < 0)
    throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${t}\` (${typeof t})`);
  return t;
}, "getForceKillAfterTimeout"), Eo = /* @__PURE__ */ i((t, e) => {
  t.kill() && (e.isCanceled = !0);
}, "spawnedCancel"), iu = /* @__PURE__ */ i((t, e, r) => {
  t.kill(e), r(Object.assign(new Error("Timed out"), { timedOut: !0, signal: e }));
}, "timeoutKill"), Co = /* @__PURE__ */ i((t, { timeout: e, killSignal: r = "SIGTERM" }, n) => {
  if (e === 0 || e === void 0)
    return n;
  let s, o = new Promise((c, p) => {
    s = setTimeout(() => {
      iu(t, r, p);
    }, e);
  }), a = n.finally(() => {
    clearTimeout(s);
  });
  return Promise.race([o, a]);
}, "setupTimeout"), Po = /* @__PURE__ */ i(({ timeout: t }) => {
  if (t !== void 0 && (!Number.isFinite(t) || t < 0))
    throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${t}\` (${typeof t})`);
}, "validateTimeout"), Ao = /* @__PURE__ */ i(async (t, { cleanup: e, detached: r }, n) => {
  if (!e || r)
    return n;
  let s = To(() => {
    t.kill();
  });
  return n.finally(() => {
    s();
  });
}, "setExitHandler");

// node_modules/execa/lib/pipe.js
var Oo = require("node:fs"), jo = require("node:child_process");

// node_modules/is-stream/index.js
function Ft(t) {
  return t !== null && typeof t == "object" && typeof t.pipe == "function";
}
i(Ft, "isStream");
function Gr(t) {
  return Ft(t) && t.writable !== !1 && typeof t._write == "function" && typeof t._writableState == "object";
}
i(Gr, "isWritableStream");

// node_modules/execa/lib/pipe.js
var au = /* @__PURE__ */ i((t) => t instanceof jo.ChildProcess && typeof t.then == "function", "isExecaChildProcess"), Kr = /* @__PURE__ */ i(
(t, e, r) => {
  if (typeof r == "string")
    return t[e].pipe((0, Oo.createWriteStream)(r)), t;
  if (Gr(r))
    return t[e].pipe(r), t;
  if (!au(r))
    throw new TypeError("The second argument must be a string, a stream or an Execa child process.");
  if (!Gr(r.stdin))
    throw new TypeError("The target child process's stdin must be available.");
  return t[e].pipe(r.stdin), r;
}, "pipeToTarget"), Ro = /* @__PURE__ */ i((t) => {
  t.stdout !== null && (t.pipeStdout = Kr.bind(void 0, t, "stdout")), t.stderr !== null && (t.pipeStderr = Kr.bind(void 0, t, "stderr")), t.
  all !== void 0 && (t.pipeAll = Kr.bind(void 0, t, "all"));
}, "addPipeMethods");

// node_modules/execa/lib/stream.js
var zt = require("node:fs"), qo = require("node:timers/promises");

// node_modules/get-stream/source/contents.js
var rt = /* @__PURE__ */ i(async (t, { init: e, convertChunk: r, getSize: n, truncateChunk: s, addChunk: o, getFinalChunk: a, finalize: c }, {
maxBuffer: p = Number.POSITIVE_INFINITY } = {}) => {
  if (!du(t))
    throw new Error("The first argument must be a Readable, a ReadableStream, or an async iterable.");
  let l = e();
  l.length = 0;
  try {
    for await (let f of t) {
      let x = uu(f), w = r[x](f, l);
      Mo({ convertedChunk: w, state: l, getSize: n, truncateChunk: s, addChunk: o, maxBuffer: p });
    }
    return cu({ state: l, convertChunk: r, getSize: n, truncateChunk: s, addChunk: o, getFinalChunk: a, maxBuffer: p }), c(l);
  } catch (f) {
    throw f.bufferedData = c(l), f;
  }
}, "getStreamContents"), cu = /* @__PURE__ */ i(({ state: t, getSize: e, truncateChunk: r, addChunk: n, getFinalChunk: s, maxBuffer: o }) => {
  let a = s(t);
  a !== void 0 && Mo({ convertedChunk: a, state: t, getSize: e, truncateChunk: r, addChunk: n, maxBuffer: o });
}, "appendFinalChunk"), Mo = /* @__PURE__ */ i(({ convertedChunk: t, state: e, getSize: r, truncateChunk: n, addChunk: s, maxBuffer: o }) => {
  let a = r(t), c = e.length + a;
  if (c <= o) {
    No(t, e, s, c);
    return;
  }
  let p = n(t, o - e.length);
  throw p !== void 0 && No(p, e, s, o), new Bt();
}, "appendChunk"), No = /* @__PURE__ */ i((t, e, r, n) => {
  e.contents = r(t, e, n), e.length = n;
}, "addNewChunk"), du = /* @__PURE__ */ i((t) => typeof t == "object" && t !== null && typeof t[Symbol.asyncIterator] == "function", "isAsyn\
cIterable"), uu = /* @__PURE__ */ i((t) => {
  let e = typeof t;
  if (e === "string")
    return "string";
  if (e !== "object" || t === null)
    return "others";
  if (globalThis.Buffer?.isBuffer(t))
    return "buffer";
  let r = Zo.call(t);
  return r === "[object ArrayBuffer]" ? "arrayBuffer" : r === "[object DataView]" ? "dataView" : Number.isInteger(t.byteLength) && Number.isInteger(
  t.byteOffset) && Zo.call(t.buffer) === "[object ArrayBuffer]" ? "typedArray" : "others";
}, "getChunkType"), { toString: Zo } = Object.prototype, Bt = class extends Error {
  static {
    i(this, "MaxBufferError");
  }
  name = "MaxBufferError";
  constructor() {
    super("maxBuffer exceeded");
  }
};

// node_modules/get-stream/source/utils.js
var zr = /* @__PURE__ */ i((t) => t, "identity"), Jr = /* @__PURE__ */ i(() => {
}, "noop"), Yr = /* @__PURE__ */ i(({ contents: t }) => t, "getContentsProp"), Wt = /* @__PURE__ */ i((t) => {
  throw new Error(`Streams in object mode are not supported: ${String(t)}`);
}, "throwObjectStream"), qt = /* @__PURE__ */ i((t) => t.length, "getLengthProp");

// node_modules/get-stream/source/array-buffer.js
async function Hr(t, e) {
  return rt(t, bu, e);
}
i(Hr, "getStreamAsArrayBuffer");
var lu = /* @__PURE__ */ i(() => ({ contents: new ArrayBuffer(0) }), "initArrayBuffer"), pu = /* @__PURE__ */ i((t) => fu.encode(t), "useTex\
tEncoder"), fu = new TextEncoder(), Lo = /* @__PURE__ */ i((t) => new Uint8Array(t), "useUint8Array"), Do = /* @__PURE__ */ i((t) => new Uint8Array(
t.buffer, t.byteOffset, t.byteLength), "useUint8ArrayWithOffset"), mu = /* @__PURE__ */ i((t, e) => t.slice(0, e), "truncateArrayBufferChunk"),
hu = /* @__PURE__ */ i((t, { contents: e, length: r }, n) => {
  let s = Vo() ? gu(e, n) : yu(e, n);
  return new Uint8Array(s).set(t, r), s;
}, "addArrayBufferChunk"), yu = /* @__PURE__ */ i((t, e) => {
  if (e <= t.byteLength)
    return t;
  let r = new ArrayBuffer($o(e));
  return new Uint8Array(r).set(new Uint8Array(t), 0), r;
}, "resizeArrayBufferSlow"), gu = /* @__PURE__ */ i((t, e) => {
  if (e <= t.maxByteLength)
    return t.resize(e), t;
  let r = new ArrayBuffer(e, { maxByteLength: $o(e) });
  return new Uint8Array(r).set(new Uint8Array(t), 0), r;
}, "resizeArrayBuffer"), $o = /* @__PURE__ */ i((t) => Uo ** Math.ceil(Math.log(t) / Math.log(Uo)), "getNewContentsLength"), Uo = 2, xu = /* @__PURE__ */ i(
({ contents: t, length: e }) => Vo() ? t : t.slice(0, e), "finalizeArrayBuffer"), Vo = /* @__PURE__ */ i(() => "resize" in ArrayBuffer.prototype,
"hasArrayBufferResize"), bu = {
  init: lu,
  convertChunk: {
    string: pu,
    buffer: Lo,
    arrayBuffer: Lo,
    dataView: Do,
    typedArray: Do,
    others: Wt
  },
  getSize: qt,
  truncateChunk: mu,
  addChunk: hu,
  getFinalChunk: Jr,
  finalize: xu
};

// node_modules/get-stream/source/buffer.js
async function Gt(t, e) {
  if (!("Buffer" in globalThis))
    throw new Error("getStreamAsBuffer() is only supported in Node.js");
  try {
    return Fo(await Hr(t, e));
  } catch (r) {
    throw r.bufferedData !== void 0 && (r.bufferedData = Fo(r.bufferedData)), r;
  }
}
i(Gt, "getStreamAsBuffer");
var Fo = /* @__PURE__ */ i((t) => globalThis.Buffer.from(t), "arrayBufferToNodeBuffer");

// node_modules/get-stream/source/string.js
async function Xr(t, e) {
  return rt(t, Tu, e);
}
i(Xr, "getStreamAsString");
var vu = /* @__PURE__ */ i(() => ({ contents: "", textDecoder: new TextDecoder() }), "initString"), Kt = /* @__PURE__ */ i((t, { textDecoder: e }) => e.
decode(t, { stream: !0 }), "useTextDecoder"), _u = /* @__PURE__ */ i((t, { contents: e }) => e + t, "addStringChunk"), wu = /* @__PURE__ */ i(
(t, e) => t.slice(0, e), "truncateStringChunk"), ku = /* @__PURE__ */ i(({ textDecoder: t }) => {
  let e = t.decode();
  return e === "" ? void 0 : e;
}, "getFinalStringChunk"), Tu = {
  init: vu,
  convertChunk: {
    string: zr,
    buffer: Kt,
    arrayBuffer: Kt,
    dataView: Kt,
    typedArray: Kt,
    others: Wt
  },
  getSize: qt,
  truncateChunk: wu,
  addChunk: _u,
  getFinalChunk: ku,
  finalize: Yr
};

// node_modules/execa/lib/stream.js
var Go = T(Wo(), 1);
var Ko = /* @__PURE__ */ i((t) => {
  if (t !== void 0)
    throw new TypeError("The `input` and `inputFile` options cannot be both set.");
}, "validateInputOptions"), Su = /* @__PURE__ */ i(({ input: t, inputFile: e }) => typeof e != "string" ? t : (Ko(t), (0, zt.readFileSync)(e)),
"getInputSync"), zo = /* @__PURE__ */ i((t) => {
  let e = Su(t);
  if (Ft(e))
    throw new TypeError("The `input` option cannot be a stream in sync mode");
  return e;
}, "handleInputSync"), Eu = /* @__PURE__ */ i(({ input: t, inputFile: e }) => typeof e != "string" ? t : (Ko(t), (0, zt.createReadStream)(e)),
"getInput"), Jo = /* @__PURE__ */ i((t, e) => {
  let r = Eu(e);
  r !== void 0 && (Ft(r) ? r.pipe(t.stdin) : t.stdin.end(r));
}, "handleInput"), Yo = /* @__PURE__ */ i((t, { all: e }) => {
  if (!e || !t.stdout && !t.stderr)
    return;
  let r = (0, Go.default)();
  return t.stdout && r.add(t.stdout), t.stderr && r.add(t.stderr), r;
}, "makeAllStream"), Qr = /* @__PURE__ */ i(async (t, e) => {
  if (!(!t || e === void 0)) {
    await (0, qo.setTimeout)(0), t.destroy();
    try {
      return await e;
    } catch (r) {
      return r.bufferedData;
    }
  }
}, "getBufferedData"), en = /* @__PURE__ */ i((t, { encoding: e, buffer: r, maxBuffer: n }) => {
  if (!(!t || !r))
    return e === "utf8" || e === "utf-8" ? Xr(t, { maxBuffer: n }) : e === null || e === "buffer" ? Gt(t, { maxBuffer: n }) : Cu(t, n, e);
}, "getStreamPromise"), Cu = /* @__PURE__ */ i(async (t, e, r) => (await Gt(t, { maxBuffer: e })).toString(r), "applyEncoding"), Ho = /* @__PURE__ */ i(
async ({ stdout: t, stderr: e, all: r }, { encoding: n, buffer: s, maxBuffer: o }, a) => {
  let c = en(t, { encoding: n, buffer: s, maxBuffer: o }), p = en(e, { encoding: n, buffer: s, maxBuffer: o }), l = en(r, { encoding: n, buffer: s,
  maxBuffer: o * 2 });
  try {
    return await Promise.all([a, c, p, l]);
  } catch (f) {
    return Promise.all([
      { error: f, signal: f.signal, timedOut: f.timedOut },
      Qr(t, c),
      Qr(e, p),
      Qr(r, l)
    ]);
  }
}, "getSpawnedResult");

// node_modules/execa/lib/promise.js
var Pu = (async () => {
})().constructor.prototype, Au = ["then", "catch", "finally"].map((t) => [
  t,
  Reflect.getOwnPropertyDescriptor(Pu, t)
]), tn = /* @__PURE__ */ i((t, e) => {
  for (let [r, n] of Au) {
    let s = typeof e == "function" ? (...o) => Reflect.apply(n.value, e(), o) : n.value.bind(e);
    Reflect.defineProperty(t, r, { ...n, value: s });
  }
}, "mergePromise"), Xo = /* @__PURE__ */ i((t) => new Promise((e, r) => {
  t.on("exit", (n, s) => {
    e({ exitCode: n, signal: s });
  }), t.on("error", (n) => {
    r(n);
  }), t.stdin && t.stdin.on("error", (n) => {
    r(n);
  });
}), "getSpawnedPromise");

// node_modules/execa/lib/command.js
var ti = require("node:buffer"), ri = require("node:child_process");
var ni = /* @__PURE__ */ i((t, e = []) => Array.isArray(e) ? [t, ...e] : [t], "normalizeArgs"), Ou = /^[\w.-]+$/, ju = /* @__PURE__ */ i((t) => typeof t !=
"string" || Ou.test(t) ? t : `"${t.replaceAll('"', '\\"')}"`, "escapeArg"), rn = /* @__PURE__ */ i((t, e) => ni(t, e).join(" "), "joinComman\
d"), nn = /* @__PURE__ */ i((t, e) => ni(t, e).map((r) => ju(r)).join(" "), "getEscapedCommand"), si = / +/g, oi = /* @__PURE__ */ i((t) => {
  let e = [];
  for (let r of t.trim().split(si)) {
    let n = e.at(-1);
    n && n.endsWith("\\") ? e[e.length - 1] = `${n.slice(0, -1)} ${r}` : e.push(r);
  }
  return e;
}, "parseCommand"), Qo = /* @__PURE__ */ i((t) => {
  let e = typeof t;
  if (e === "string")
    return t;
  if (e === "number")
    return String(t);
  if (e === "object" && t !== null && !(t instanceof ri.ChildProcess) && "stdout" in t) {
    let r = typeof t.stdout;
    if (r === "string")
      return t.stdout;
    if (ti.Buffer.isBuffer(t.stdout))
      return t.stdout.toString();
    throw new TypeError(`Unexpected "${r}" stdout in template expression`);
  }
  throw new TypeError(`Unexpected "${e}" in template expression`);
}, "parseExpression"), ei = /* @__PURE__ */ i((t, e, r) => r || t.length === 0 || e.length === 0 ? [...t, ...e] : [
  ...t.slice(0, -1),
  `${t.at(-1)}${e[0]}`,
  ...e.slice(1)
], "concatTokens"), Ru = /* @__PURE__ */ i(({ templates: t, expressions: e, tokens: r, index: n, template: s }) => {
  let o = s ?? t.raw[n], a = o.split(si).filter(Boolean), c = ei(
    r,
    a,
    o.startsWith(" ")
  );
  if (n === e.length)
    return c;
  let p = e[n], l = Array.isArray(p) ? p.map((f) => Qo(f)) : [Qo(p)];
  return ei(
    c,
    l,
    o.endsWith(" ")
  );
}, "parseTemplate"), sn = /* @__PURE__ */ i((t, e) => {
  let r = [];
  for (let [n, s] of t.entries())
    r = Ru({ templates: t, expressions: e, tokens: r, index: n, template: s });
  return r;
}, "parseTemplates");

// node_modules/execa/lib/verbose.js
var ii = require("node:util"), ai = T(require("node:process"), 1);
var ci = (0, ii.debuglog)("execa").enabled, Jt = /* @__PURE__ */ i((t, e) => String(t).padStart(e, "0"), "padField"), Nu = /* @__PURE__ */ i(
() => {
  let t = /* @__PURE__ */ new Date();
  return `${Jt(t.getHours(), 2)}:${Jt(t.getMinutes(), 2)}:${Jt(t.getSeconds(), 2)}.${Jt(t.getMilliseconds(), 3)}`;
}, "getTimestamp"), on = /* @__PURE__ */ i((t, { verbose: e }) => {
  e && ai.default.stderr.write(`[${Nu()}] ${t}
`);
}, "logCommand");

// node_modules/execa/index.js
var Zu = 1e3 * 1e3 * 100, Mu = /* @__PURE__ */ i(({ env: t, extendEnv: e, preferLocal: r, localDir: n, execPath: s }) => {
  let o = e ? { ...nt.default.env, ...t } : t;
  return r ? fo({ env: o, cwd: n, execPath: s }) : o;
}, "getEnv"), fi = /* @__PURE__ */ i((t, e, r = {}) => {
  let n = pi.default._parse(t, e, r);
  return t = n.command, e = n.args, r = n.options, r = {
    maxBuffer: Zu,
    buffer: !0,
    stripFinalNewline: !0,
    extendEnv: !0,
    preferLocal: !1,
    localDir: r.cwd || nt.default.cwd(),
    execPath: nt.default.execPath,
    encoding: "utf8",
    reject: !0,
    cleanup: !0,
    all: !1,
    windowsHide: !0,
    verbose: ci,
    ...r
  }, r.env = Mu(r), r.stdio = ko(r), nt.default.platform === "win32" && li.default.basename(t, ".exe") === "cmd" && e.unshift("/q"), { file: t,
  args: e, options: r, parsed: n };
}, "handleArguments"), st = /* @__PURE__ */ i((t, e, r) => typeof e != "string" && !ui.Buffer.isBuffer(e) ? r === void 0 ? void 0 : "" : t.stripFinalNewline ?
Zr(e) : e, "handleOutput");
function mi(t, e, r) {
  let n = fi(t, e, r), s = rn(t, e), o = nn(t, e);
  on(o, n.options), Po(n.options);
  let a;
  try {
    a = Yt.default.spawn(n.file, n.args, n.options);
  } catch (_) {
    let P = new Yt.default.ChildProcess(), E = Promise.reject(tt({
      error: _,
      stdout: "",
      stderr: "",
      all: "",
      command: s,
      escapedCommand: o,
      parsed: n,
      timedOut: !1,
      isCanceled: !1,
      killed: !1
    }));
    return tn(P, E), P;
  }
  let c = Xo(a), p = Co(a, n.options, c), l = Ao(a, n.options, p), f = { isCanceled: !1 };
  a.kill = So.bind(null, a.kill.bind(a)), a.cancel = Eo.bind(null, a, f);
  let w = ho(/* @__PURE__ */ i(async () => {
    let [{ error: _, exitCode: P, signal: E, timedOut: A }, W, Be, Te] = await Ho(a, n.options, l), We = st(n.options, W), ht = st(n.options,
    Be), yt = st(n.options, Te);
    if (_ || P !== 0 || E !== null) {
      let k = tt({
        error: _,
        exitCode: P,
        signal: E,
        stdout: We,
        stderr: ht,
        all: yt,
        command: s,
        escapedCommand: o,
        parsed: n,
        timedOut: A,
        isCanceled: f.isCanceled || (n.options.signal ? n.options.signal.aborted : !1),
        killed: a.killed
      });
      if (!n.options.reject)
        return k;
      throw k;
    }
    return {
      command: s,
      escapedCommand: o,
      exitCode: 0,
      stdout: We,
      stderr: ht,
      all: yt,
      failed: !1,
      timedOut: !1,
      isCanceled: !1,
      killed: !1
    };
  }, "handlePromise"));
  return Jo(a, n.options), a.all = Yo(a, n.options), Ro(a), tn(a, w), a;
}
i(mi, "execa");
function Lu(t, e, r) {
  let n = fi(t, e, r), s = rn(t, e), o = nn(t, e);
  on(o, n.options);
  let a = zo(n.options), c;
  try {
    c = Yt.default.spawnSync(n.file, n.args, { ...n.options, input: a });
  } catch (f) {
    throw tt({
      error: f,
      stdout: "",
      stderr: "",
      all: "",
      command: s,
      escapedCommand: o,
      parsed: n,
      timedOut: !1,
      isCanceled: !1,
      killed: !1
    });
  }
  let p = st(n.options, c.stdout, c.error), l = st(n.options, c.stderr, c.error);
  if (c.error || c.status !== 0 || c.signal !== null) {
    let f = tt({
      stdout: p,
      stderr: l,
      error: c.error,
      signal: c.signal,
      exitCode: c.status,
      command: s,
      escapedCommand: o,
      parsed: n,
      timedOut: c.error && c.error.code === "ETIMEDOUT",
      isCanceled: !1,
      killed: c.signal !== null
    });
    if (!n.options.reject)
      return f;
    throw f;
  }
  return {
    command: s,
    escapedCommand: o,
    exitCode: 0,
    stdout: p,
    stderr: l,
    failed: !1,
    timedOut: !1,
    isCanceled: !1,
    killed: !1
  };
}
i(Lu, "execaSync");
var Du = /* @__PURE__ */ i(({ input: t, inputFile: e, stdio: r }) => t === void 0 && e === void 0 && r === void 0 ? { stdin: "inherit" } : {},
"normalizeScriptStdin"), di = /* @__PURE__ */ i((t = {}) => ({
  preferLocal: !0,
  ...Du(t),
  ...t
}), "normalizeScriptOptions");
function hi(t) {
  function e(r, ...n) {
    if (!Array.isArray(r))
      return hi({ ...t, ...r });
    let [s, ...o] = sn(r, n);
    return mi(s, o, di(t));
  }
  return i(e, "$"), e.sync = (r, ...n) => {
    if (!Array.isArray(r))
      throw new TypeError("Please use $(options).sync`command` instead of $.sync(options)`command`.");
    let [s, ...o] = sn(r, n);
    return Lu(s, o, di(t));
  }, e;
}
i(hi, "create$");
var Em = hi();
function ot(t, e) {
  let [r, ...n] = oi(t);
  return mi(r, n, e);
}
i(ot, "execaCommand");

// src/telemetry/exec-command-count-lines.ts
async function Ht(t, e) {
  let r = ot(t, { shell: !0, buffer: !1, ...e });
  if (!r.stdout)
    throw new Error("Unexpected missing stdout");
  let n = 0, s = (0, yi.createInterface)(r.stdout);
  return s.on("line", () => {
    n += 1;
  }), await r, s.close(), n;
}
i(Ht, "execCommandCountLines");

// src/common/utils/file-cache.ts
var it = require("node:crypto"), M = require("node:fs"), V = require("node:fs/promises"), xi = require("node:os"), De = require("node:path");
var Xt = class {
  static {
    i(this, "FileSystemCache");
  }
  constructor(e = {}) {
    this.prefix = (e.ns || e.prefix || "") + "-", this.hash_alg = e.hash_alg || "sha256", this.cache_dir = e.basePath || (0, De.join)((0, xi.tmpdir)(),
    (0, it.randomBytes)(15).toString("base64").replace(/\//g, "-")), this.ttl = e.ttl || 0, (0, it.createHash)(this.hash_alg), (0, M.mkdirSync)(
    this.cache_dir, { recursive: !0 });
  }
  generateHash(e) {
    return (0, De.join)(this.cache_dir, this.prefix + (0, it.createHash)(this.hash_alg).update(e).digest("hex"));
  }
  isExpired(e, r) {
    return e.ttl != null && r > e.ttl;
  }
  parseCacheData(e, r) {
    let n = JSON.parse(e);
    return this.isExpired(n, Date.now()) ? r : n.content;
  }
  parseSetData(e, r, n = {}) {
    let s = n.ttl ?? this.ttl;
    return JSON.stringify({ key: e, content: r, ...s && { ttl: Date.now() + s * 1e3 } });
  }
  async get(e, r) {
    try {
      let n = await (0, V.readFile)(this.generateHash(e), "utf8");
      return this.parseCacheData(n, r);
    } catch {
      return r;
    }
  }
  getSync(e, r) {
    try {
      let n = (0, M.readFileSync)(this.generateHash(e), "utf8");
      return this.parseCacheData(n, r);
    } catch {
      return r;
    }
  }
  async set(e, r, n = {}) {
    let s = typeof n == "number" ? { ttl: n } : n;
    (0, M.mkdirSync)(this.cache_dir, { recursive: !0 }), await (0, V.writeFile)(this.generateHash(e), this.parseSetData(e, r, s), {
      encoding: s.encoding || "utf8"
    });
  }
  setSync(e, r, n = {}) {
    let s = typeof n == "number" ? { ttl: n } : n;
    (0, M.mkdirSync)(this.cache_dir, { recursive: !0 }), (0, M.writeFileSync)(this.generateHash(e), this.parseSetData(e, r, s), {
      encoding: s.encoding || "utf8"
    });
  }
  async setMany(e, r) {
    await Promise.all(e.map((n) => this.set(n.key, n.content ?? n.value, r)));
  }
  setManySync(e, r) {
    e.forEach((n) => this.setSync(n.key, n.content ?? n.value, r));
  }
  async remove(e) {
    await (0, V.rm)(this.generateHash(e), { force: !0 });
  }
  removeSync(e) {
    (0, M.rmSync)(this.generateHash(e), { force: !0 });
  }
  async clear() {
    let e = await (0, V.readdir)(this.cache_dir);
    await Promise.all(
      e.filter((r) => r.startsWith(this.prefix)).map((r) => (0, V.rm)((0, De.join)(this.cache_dir, r), { force: !0 }))
    );
  }
  clearSync() {
    (0, M.readdirSync)(this.cache_dir).filter((e) => e.startsWith(this.prefix)).forEach((e) => (0, M.rmSync)((0, De.join)(this.cache_dir, e),
    { force: !0 }));
  }
  async getAll() {
    let e = Date.now(), r = await (0, V.readdir)(this.cache_dir);
    return (await Promise.all(
      r.filter((s) => s.startsWith(this.prefix)).map((s) => (0, V.readFile)((0, De.join)(this.cache_dir, s), "utf8"))
    )).map((s) => JSON.parse(s)).filter((s) => s.content && !this.isExpired(s, e));
  }
  async load() {
    return {
      files: (await this.getAll()).map((r) => ({
        path: this.generateHash(r.key),
        value: r.content,
        key: r.key
      }))
    };
  }
};
function cn(t) {
  return new Xt(t);
}
i(cn, "createFileSystemCache");

// src/common/utils/resolve-path-in-sb-cache.ts
var hn = require("node:path");

// node_modules/find-cache-dir/index.js
var Ni = T(require("node:process"), 1), Ve = T(require("node:path"), 1), dt = T(require("node:fs"), 1), Zi = T(vi(), 1);

// ../node_modules/pkg-dir/index.js
var Ai = T(require("node:path"), 1);

// ../node_modules/pkg-dir/node_modules/find-up/index.js
var ct = T(require("node:path"), 1), Ci = require("node:url");

// ../node_modules/locate-path/index.js
var ln = T(require("node:process"), 1), pn = T(require("node:path"), 1), Ue = T(require("node:fs"), 1), wi = require("node:url");

// ../node_modules/locate-path/node_modules/p-limit/index.js
_i();
function Qt(t) {
  if (!((Number.isInteger(t) || t === Number.POSITIVE_INFINITY) && t > 0))
    throw new TypeError("Expected `concurrency` to be a number from 1 and up");
  let e = new at(), r = 0, n = /* @__PURE__ */ i(() => {
    r--, e.size > 0 && e.dequeue()();
  }, "next"), s = /* @__PURE__ */ i(async (c, p, l) => {
    r++;
    let f = (async () => c(...l))();
    p(f);
    try {
      await f;
    } catch {
    }
    n();
  }, "run"), o = /* @__PURE__ */ i((c, p, l) => {
    e.enqueue(s.bind(void 0, c, p, l)), (async () => (await Promise.resolve(), r < t && e.size > 0 && e.dequeue()()))();
  }, "enqueue"), a = /* @__PURE__ */ i((c, ...p) => new Promise((l) => {
    o(c, l, p);
  }), "generator");
  return Object.defineProperties(a, {
    activeCount: {
      get: /* @__PURE__ */ i(() => r, "get")
    },
    pendingCount: {
      get: /* @__PURE__ */ i(() => e.size, "get")
    },
    clearQueue: {
      value: /* @__PURE__ */ i(() => {
        e.clear();
      }, "value")
    }
  }), a;
}
i(Qt, "pLimit");

// ../node_modules/locate-path/node_modules/p-locate/index.js
var er = class extends Error {
  static {
    i(this, "EndError");
  }
  constructor(e) {
    super(), this.value = e;
  }
}, Vu = /* @__PURE__ */ i(async (t, e) => e(await t), "testElement"), Fu = /* @__PURE__ */ i(async (t) => {
  let e = await Promise.all(t);
  if (e[1] === !0)
    throw new er(e[0]);
  return !1;
}, "finder");
async function un(t, e, {
  concurrency: r = Number.POSITIVE_INFINITY,
  preserveOrder: n = !0
} = {}) {
  let s = Qt(r), o = [...t].map((c) => [c, s(Vu, c, e)]), a = Qt(n ? 1 : Number.POSITIVE_INFINITY);
  try {
    await Promise.all(o.map((c) => a(Fu, c)));
  } catch (c) {
    if (c instanceof er)
      return c.value;
    throw c;
  }
}
i(un, "pLocate");

// ../node_modules/locate-path/index.js
var ki = {
  directory: "isDirectory",
  file: "isFile"
};
function Ti(t) {
  if (!Object.hasOwnProperty.call(ki, t))
    throw new Error(`Invalid type specified: ${t}`);
}
i(Ti, "checkType");
var Ii = /* @__PURE__ */ i((t, e) => e[ki[t]](), "matchType"), Si = /* @__PURE__ */ i((t) => t instanceof URL ? (0, wi.fileURLToPath)(t) : t,
"toPath");
async function tr(t, {
  cwd: e = ln.default.cwd(),
  type: r = "file",
  allowSymlinks: n = !0,
  concurrency: s,
  preserveOrder: o
} = {}) {
  Ti(r), e = Si(e);
  let a = n ? Ue.promises.stat : Ue.promises.lstat;
  return un(t, async (c) => {
    try {
      let p = await a(pn.default.resolve(e, c));
      return Ii(r, p);
    } catch {
      return !1;
    }
  }, { concurrency: s, preserveOrder: o });
}
i(tr, "locatePath");
function $e(t, {
  cwd: e = ln.default.cwd(),
  type: r = "file",
  allowSymlinks: n = !0
} = {}) {
  Ti(r), e = Si(e);
  let s = n ? Ue.default.statSync : Ue.default.lstatSync;
  for (let o of t)
    try {
      let a = s(pn.default.resolve(e, o), {
        throwIfNoEntry: !1
      });
      if (!a)
        continue;
      if (Ii(r, a))
        return o;
    } catch {
    }
}
i($e, "locatePathSync");

// ../node_modules/pkg-dir/node_modules/path-exists/index.js
var Ei = T(require("node:fs"), 1);

// ../node_modules/pkg-dir/node_modules/find-up/index.js
var Bu = /* @__PURE__ */ i((t) => t instanceof URL ? (0, Ci.fileURLToPath)(t) : t, "toPath"), Wu = Symbol("findUpStop");
function qu(t, e = {}) {
  let r = ct.default.resolve(Bu(e.cwd) || ""), { root: n } = ct.default.parse(r), s = e.stopAt || n, o = e.limit || Number.POSITIVE_INFINITY,
  a = [t].flat(), c = /* @__PURE__ */ i((l) => {
    if (typeof t != "function")
      return $e(a, l);
    let f = t(l.cwd);
    return typeof f == "string" ? $e([f], l) : f;
  }, "runMatcher"), p = [];
  for (; ; ) {
    let l = c({ ...e, cwd: r });
    if (l === Wu || (l && p.push(ct.default.resolve(r, l)), r === s || p.length >= o))
      break;
    r = ct.default.dirname(r);
  }
  return p;
}
i(qu, "findUpMultipleSync");
function Pi(t, e = {}) {
  return qu(t, { ...e, limit: 1 })[0];
}
i(Pi, "findUpSync");

// ../node_modules/pkg-dir/index.js
function Oi({ cwd: t } = {}) {
  let e = Pi("package.json", { cwd: t });
  return e && Ai.default.dirname(e);
}
i(Oi, "packageDirectorySync");

// node_modules/find-cache-dir/index.js
var { env: fn, cwd: Gu } = Ni.default, ji = /* @__PURE__ */ i((t) => {
  try {
    return dt.default.accessSync(t, dt.default.constants.W_OK), !0;
  } catch {
    return !1;
  }
}, "isWritable");
function Ri(t, e) {
  return e.create && dt.default.mkdirSync(t, { recursive: !0 }), t;
}
i(Ri, "useDirectory");
function Ku(t) {
  let e = Ve.default.join(t, "node_modules");
  if (!(!ji(e) && (dt.default.existsSync(e) || !ji(Ve.default.join(t)))))
    return e;
}
i(Ku, "getNodeModuleDirectory");
function mn(t = {}) {
  if (fn.CACHE_DIR && !["true", "false", "1", "0"].includes(fn.CACHE_DIR))
    return Ri(Ve.default.join(fn.CACHE_DIR, t.name), t);
  let { cwd: e = Gu(), files: r } = t;
  if (r) {
    if (!Array.isArray(r))
      throw new TypeError(`Expected \`files\` option to be an array, got \`${typeof r}\`.`);
    e = (0, Zi.default)(r.map((s) => Ve.default.resolve(e, s)));
  }
  if (e = Oi({ cwd: e }), !(!e || !Ku(e)))
    return Ri(Ve.default.join(e, "node_modules", ".cache", t.name), t);
}
i(mn, "findCacheDirectory");

// src/common/utils/resolve-path-in-sb-cache.ts
function Mi(t, e = "default") {
  let r = mn({ name: "storybook" });
  return r ||= (0, hn.join)(process.cwd(), "node_modules", ".cache", "storybook"), (0, hn.join)(r, e, t);
}
i(Mi, "resolvePathInStorybookCache");

// ../node_modules/find-up/index.js
var F = T(require("node:path"), 1);

// ../node_modules/find-up/node_modules/unicorn-magic/node.js
var Li = require("node:url");
function ut(t) {
  return t instanceof URL ? (0, Li.fileURLToPath)(t) : t;
}
i(ut, "toPath");

// ../node_modules/find-up/node_modules/path-exists/index.js
var Di = T(require("node:fs"), 1);

// ../node_modules/find-up/index.js
var Ui = Symbol("findUpStop");
async function zu(t, e = {}) {
  let r = F.default.resolve(ut(e.cwd) ?? ""), { root: n } = F.default.parse(r), s = F.default.resolve(r, ut(e.stopAt ?? n)), o = e.limit ?? Number.
  POSITIVE_INFINITY, a = [t].flat(), c = /* @__PURE__ */ i(async (l) => {
    if (typeof t != "function")
      return tr(a, l);
    let f = await t(l.cwd);
    return typeof f == "string" ? tr([f], l) : f;
  }, "runMatcher"), p = [];
  for (; ; ) {
    let l = await c({ ...e, cwd: r });
    if (l === Ui || (l && p.push(F.default.resolve(r, l)), r === s || p.length >= o))
      break;
    r = F.default.dirname(r);
  }
  return p;
}
i(zu, "findUpMultiple");
function Ju(t, e = {}) {
  let r = F.default.resolve(ut(e.cwd) ?? ""), { root: n } = F.default.parse(r), s = F.default.resolve(r, ut(e.stopAt) ?? n), o = e.limit ?? Number.
  POSITIVE_INFINITY, a = [t].flat(), c = /* @__PURE__ */ i((l) => {
    if (typeof t != "function")
      return $e(a, l);
    let f = t(l.cwd);
    return typeof f == "string" ? $e([f], l) : f;
  }, "runMatcher"), p = [];
  for (; ; ) {
    let l = c({ ...e, cwd: r });
    if (l === Ui || (l && p.push(F.default.resolve(r, l)), r === s || p.length >= o))
      break;
    r = F.default.dirname(r);
  }
  return p;
}
i(Ju, "findUpMultipleSync");
async function $i(t, e = {}) {
  return (await zu(t, { ...e, limit: 1 }))[0];
}
i($i, "findUp");
function lt(t, e = {}) {
  return Ju(t, { ...e, limit: 1 })[0];
}
i(lt, "findUpSync");

// src/common/utils/paths.ts
var B = require("node:path");

// src/common/js-package-manager/constants.ts
var Yu = "package-lock.json", Hu = "pnpm-lock.yaml", Xu = "yarn.lock", Qu = "bun.lock", el = "bun.lockb", Vi = [
  Yu,
  Hu,
  Xu,
  Qu,
  el
];

// src/common/utils/paths.ts
var z, rr = /* @__PURE__ */ i(() => {
  if (z)
    return z;
  if (process.env.STORYBOOK_PROJECT_ROOT)
    return process.env.STORYBOOK_PROJECT_ROOT;
  try {
    let t = lt(".git", { type: "directory" }) || lt(".svn", { type: "directory" }) || lt(".hg", { type: "directory" });
    if (t)
      return z = (0, B.join)(t, ".."), z;
  } catch (t) {
    process.stdout.write(`
error searching for repository root: ${t}
`);
  }
  try {
    let t = lt(Vi, { type: "file" });
    if (t)
      return z = (0, B.join)(t, ".."), z;
  } catch (t) {
    process.stdout.write(`
error searching for lock file: ${t}
`);
  }
  try {
    let [t, e] = __dirname.split(`${B.sep}node_modules${B.sep}`, 2);
    if (e && !t.includes(`${B.sep}npm-cache${B.sep}`) && !(0, B.relative)(t, process.cwd()).startsWith(".."))
      return z = t, z;
  } catch (t) {
    process.stdout.write(`
error searching for splitDirname: ${t}
`);
  }
  return z = process.cwd(), z;
}, "getProjectRoot");

// src/telemetry/run-telemetry-operation.ts
var Fi = cn({
  basePath: Mi("telemetry"),
  ns: "storybook",
  ttl: 24 * 60 * 60 * 1e3
  // 24h
}), nr = /* @__PURE__ */ i(async (t, e) => {
  let r = await Fi.get(t);
  return r === void 0 && (r = await e(), r !== void 0 && await Fi.set(t, r)), r;
}, "runTelemetryOperation");

// src/telemetry/get-application-file-count.ts
var tl = ["page", "screen"], rl = ["js", "jsx", "ts", "tsx"], nl = /* @__PURE__ */ i(async (t) => {
  let r = tl.flatMap((n) => [
    n,
    [n[0].toUpperCase(), ...n.slice(1)].join("")
  ]).flatMap(
    (n) => rl.map((s) => `"${t}${Bi.sep}*${n}*.${s}"`)
  );
  try {
    let n = `git ls-files -- ${r.join(" ")}`;
    return await Ht(n);
  } catch {
    return;
  }
}, "getApplicationFilesCountUncached"), Wi = /* @__PURE__ */ i(async (t) => nr(
  "applicationFiles",
  async () => nl(t)
), "getApplicationFileCount");

// src/telemetry/get-chromatic-version.ts
function qi(t) {
  let e = t.dependencies?.chromatic || t.devDependencies?.chromatic || t.peerDependencies?.chromatic;
  return e || (t.scripts && Object.values(t.scripts).find((r) => r?.match(/chromatic/)) ? "latest" : void 0);
}
i(qi, "getChromaticVersionSpecifier");

// src/telemetry/get-framework-info.ts
var Ji = require("node:path"), Yi = require("storybook/internal/common");

// src/telemetry/package-json.ts
var Gi = require("node:fs/promises"), Ki = require("node:path");
var yn = /* @__PURE__ */ i(async (t) => {
  let e = Object.keys(t);
  return Promise.all(e.map(sr));
}, "getActualPackageVersions"), sr = /* @__PURE__ */ i(async (t) => {
  try {
    let e = await gn(t);
    return {
      name: e?.name || t,
      version: e?.version || null
    };
  } catch {
    return {
      name: t,
      version: null
    };
  }
}, "getActualPackageVersion"), gn = /* @__PURE__ */ i(async (t) => {
  try {
    let e = await $i("package.json", { cwd: require.resolve(t) });
    return e || (e = require.resolve((0, Ki.join)(t, "package.json"), {
      paths: [process.cwd()]
    })), JSON.parse(await (0, Gi.readFile)(e, { encoding: "utf8" }));
  } catch {
    return;
  }
}, "getActualPackageJson");

// src/telemetry/get-framework-info.ts
var sl = [
  "html",
  "react",
  "svelte",
  "vue3",
  "preact",
  "server",
  "vue",
  "web-components",
  "angular",
  "ember"
], ol = ["builder-webpack5", "builder-vite"];
function zi(t, e) {
  let { name: r = "", version: n, dependencies: s, devDependencies: o, peerDependencies: a } = t, c = {
    // We include the framework itself because it may be a renderer too (e.g. angular)
    [r]: n,
    ...s,
    ...o,
    ...a
  };
  return e.map((p) => `@storybook/${p}`).find((p) => c[p]);
}
i(zi, "findMatchingPackage");
var il = /* @__PURE__ */ i((t) => {
  let e = (0, Ji.normalize)(t).replace(new RegExp(/\\/, "g"), "/");
  return Object.keys(Yi.frameworkPackages).find((n) => e.endsWith(n)) || Ie(t).replace(/.*node_modules[\\/]/, "");
}, "getFrameworkPackageName");
async function Hi(t) {
  if (!t?.framework)
    return {};
  let e = typeof t.framework == "string" ? t.framework : t.framework?.name;
  if (!e)
    return {};
  let r = await gn(e);
  if (!r)
    return {};
  let n = zi(r, ol), s = zi(r, sl), o = il(e), a = typeof t.framework == "object" ? t.framework.options : {};
  return {
    framework: {
      name: o,
      options: a
    },
    builder: n,
    renderer: s
  };
}
i(Hi, "getFrameworkInfo");

// src/telemetry/get-has-router-package.ts
var al = /* @__PURE__ */ new Set([
  "react-router",
  "react-router-dom",
  "remix",
  "@tanstack/react-router",
  "expo-router",
  "@reach/router",
  "react-easy-router",
  "@remix-run/router",
  "wouter",
  "wouter-preact",
  "preact-router",
  "vue-router",
  "unplugin-vue-router",
  "@angular/router",
  "@solidjs/router",
  // metaframeworks that imply routing
  "next",
  "react-scripts",
  "gatsby",
  "nuxt",
  "@sveltejs/kit"
]);
function Xi(t) {
  return Object.keys(t?.dependencies ?? {}).some(
    (e) => al.has(e)
  );
}
i(Xi, "getHasRouterPackage");

// src/telemetry/get-monorepo-type.ts
var pt = require("node:fs"), or = require("node:path"), ir = require("storybook/internal/common");
var Qi = {
  Nx: "nx.json",
  Turborepo: "turbo.json",
  Lerna: "lerna.json",
  Rush: "rush.json",
  Lage: "lage.config.json"
}, ea = /* @__PURE__ */ i(() => {
  let e = Object.keys(Qi).find((n) => {
    let s = (0, or.join)((0, ir.getProjectRoot)(), Qi[n]);
    return (0, pt.existsSync)(s);
  });
  if (e)
    return e;
  if (!(0, pt.existsSync)((0, or.join)((0, ir.getProjectRoot)(), "package.json")))
    return;
  if (JSON.parse(
    (0, pt.readFileSync)((0, or.join)((0, ir.getProjectRoot)(), "package.json"), { encoding: "utf8" })
  )?.workspaces)
    return "Workspaces";
}, "getMonorepoType");

// ../node_modules/package-manager-detector/dist/constants.mjs
var ta = [
  "npm",
  "yarn",
  "yarn@berry",
  "pnpm",
  "pnpm@6",
  "bun",
  "deno"
], xn = {
  "bun.lock": "bun",
  "bun.lockb": "bun",
  "deno.lock": "deno",
  "pnpm-lock.yaml": "pnpm",
  "pnpm-workspace.yaml": "pnpm",
  "yarn.lock": "yarn",
  "package-lock.json": "npm",
  "npm-shrinkwrap.json": "npm"
}, bn = {
  "node_modules/.deno/": "deno",
  "node_modules/.pnpm/": "pnpm",
  "node_modules/.yarn-state.yml": "yarn",
  // yarn v2+ (node-modules)
  "node_modules/.yarn_integrity": "yarn",
  // yarn v1
  "node_modules/.package-lock.json": "npm",
  ".pnp.cjs": "yarn",
  // yarn v3+ (pnp)
  ".pnp.js": "yarn",
  // yarn v2 (pnp)
  "bun.lock": "bun",
  "bun.lockb": "bun"
};

// ../node_modules/package-manager-detector/dist/detect.mjs
var _n = T(require("node:fs/promises"), 1), re = T(require("node:path"), 1), na = T(require("node:process"), 1);
async function vn(t, e) {
  try {
    let r = await _n.default.stat(t);
    return e === "file" ? r.isFile() : r.isDirectory();
  } catch {
    return !1;
  }
}
i(vn, "pathExists");
function* cl(t = na.default.cwd()) {
  let e = re.default.resolve(t), { root: r } = re.default.parse(e);
  for (; e && e !== r; )
    yield e, e = re.default.dirname(e);
}
i(cl, "lookup");
async function ra(t, e) {
  return !t || !vn(t, "file") ? null : await ul(t, e);
}
i(ra, "parsePackageJson");
async function wn(t = {}) {
  let { cwd: e, strategies: r = ["lockfile", "packageManager-field", "devEngines-field"], onUnknown: n } = t;
  for (let s of cl(e))
    for (let o of r)
      switch (o) {
        case "lockfile": {
          for (let a of Object.keys(xn))
            if (await vn(re.default.join(s, a), "file")) {
              let c = xn[a], p = await ra(re.default.join(s, "package.json"), n);
              return p || { name: c, agent: c };
            }
          break;
        }
        case "packageManager-field":
        case "devEngines-field": {
          let a = await ra(re.default.join(s, "package.json"), n);
          if (a)
            return a;
          break;
        }
        case "install-metadata": {
          for (let a of Object.keys(bn)) {
            let c = a.endsWith("/") ? "dir" : "file";
            if (await vn(re.default.join(s, a), c)) {
              let p = bn[a], l = p === "yarn" ? ll(a) ? "yarn" : "yarn@berry" : p;
              return { name: p, agent: l };
            }
          }
          break;
        }
      }
  return null;
}
i(wn, "detect");
function dl(t) {
  let e = /* @__PURE__ */ i((r) => r?.match(/\d+(\.\d+){0,2}/)?.[0] ?? r, "handelVer");
  if (typeof t.packageManager == "string") {
    let [r, n] = t.packageManager.replace(/^\^/, "").split("@");
    return { name: r, ver: e(n) };
  }
  if (typeof t.devEngines?.packageManager?.name == "string")
    return {
      name: t.devEngines.packageManager.name,
      ver: e(t.devEngines.packageManager.version)
    };
}
i(dl, "getNameAndVer");
async function ul(t, e) {
  try {
    let r = JSON.parse(await _n.default.readFile(t, "utf8")), n, s = dl(r);
    if (s) {
      let o = s.name, a = s.ver, c = a;
      return o === "yarn" && a && Number.parseInt(a) > 1 ? (n = "yarn@berry", c = "berry", { name: o, agent: n, version: c }) : o === "pnpm" &&
      a && Number.parseInt(a) < 7 ? (n = "pnpm@6", { name: o, agent: n, version: c }) : ta.includes(o) ? (n = o, { name: o, agent: n, version: c }) :
      e?.(r.packageManager) ?? null;
    }
  } catch {
  }
  return null;
}
i(ul, "handlePackageManager");
function ll(t) {
  return t.endsWith(".yarn_integrity");
}
i(ll, "isMetadataYarnClassic");

// ../node_modules/package-manager-detector/dist/index.mjs
var Ky = require("node:fs/promises"), zy = require("node:path"), Jy = require("node:process");

// src/telemetry/get-package-manager-info.ts
var sa = /* @__PURE__ */ i(async () => {
  let t = await wn({ cwd: rr() });
  if (!t)
    return;
  let e = "node_modules";
  if (t.name === "yarn")
    try {
      let { stdout: r } = await ot("yarn config get nodeLinker", {
        cwd: rr()
      });
      e = r.trim();
    } catch {
    }
  if (t.name === "pnpm")
    try {
      let { stdout: r } = await ot("pnpm config get nodeLinker", {
        cwd: rr()
      });
      e = r.trim() ?? "isolated";
    } catch {
    }
  return {
    type: t.name,
    version: t.version,
    agent: t.agent,
    nodeLinker: e
  };
}, "getPackageManagerInfo");

// src/telemetry/get-portable-stories-usage.ts
var pl = /* @__PURE__ */ i(async (t) => {
  try {
    let e = "git grep -l composeStor" + (t ? ` -- ${t}` : "");
    return await Ht(e);
  } catch (e) {
    return e.exitCode === 1 ? 0 : void 0;
  }
}, "getPortableStoriesFileCountUncached"), oa = /* @__PURE__ */ i(async (t) => nr(
  "portableStories",
  async () => pl(t)
), "getPortableStoriesFileCount");

// src/telemetry/storybook-metadata.ts
var kn = {
  next: "Next",
  "react-scripts": "CRA",
  gatsby: "Gatsby",
  "@nuxtjs/storybook": "nuxt",
  "@nrwl/storybook": "nx",
  "@vue/cli-service": "vue-cli",
  "@sveltejs/kit": "sveltekit"
}, Tn = /* @__PURE__ */ i((t) => Ie(t).replace(/\/dist\/.*/, "").replace(/\.[mc]?[tj]?s[x]?$/, "").replace(/\/register$/, "").replace(/\/manager$/,
"").replace(/\/preset$/, ""), "sanitizeAddonName"), ca = /* @__PURE__ */ i(async ({
  packageJsonPath: t,
  packageJson: e,
  mainConfig: r,
  configDir: n
}) => {
  let s = await ks(), o = {
    generatedAt: (/* @__PURE__ */ new Date()).getTime(),
    userSince: s.value.userSince,
    hasCustomBabel: !1,
    hasCustomWebpack: !1,
    hasStaticDirs: !1,
    hasStorybookEslint: !1,
    refCount: 0
  }, a = {
    ...e?.dependencies,
    ...e?.devDependencies,
    ...e?.peerDependencies
  }, c = Object.keys(a).find((k) => !!kn[k]);
  if (c) {
    let { version: k } = await sr(c);
    o.metaFramework = {
      name: kn[c],
      packageName: c,
      version: k || "unknown"
    };
  }
  let p = [
    "playwright",
    "vitest",
    "jest",
    "cypress",
    "nightwatch",
    "webdriver",
    "@web/test-runner",
    "puppeteer",
    "karma",
    "jasmine",
    "chai",
    "testing-library",
    "@ngneat/spectator",
    "wdio",
    "msw",
    "miragejs",
    "sinon",
    "chromatic"
  ], l = Object.keys(a).filter(
    (k) => p.find((O) => k.includes(O))
  );
  o.testPackages = Object.fromEntries(
    await Promise.all(
      l.map(async (k) => [k, (await sr(k))?.version])
    )
  ), o.hasRouterPackage = Xi(e);
  let f = ea();
  f && (o.monorepo = f), o.packageManager = await sa();
  let x = a.typescript ? "typescript" : "javascript";
  if (!r)
    return {
      ...o,
      storybookVersionSpecifier: ne.versions.storybook,
      language: x
    };
  o.hasCustomBabel = !!r.babel, o.hasCustomWebpack = !!r.webpackFinal, o.hasStaticDirs = !!r.staticDirs, typeof r.typescript == "object" && (o.
  typescriptOptions = r.typescript);
  let w = await Hi(r);
  typeof r.refs == "object" && (o.refCount = Object.keys(r.refs).length), typeof r.features == "object" && (o.features = r.features);
  let _ = {};
  r.addons && r.addons.forEach((k) => {
    let O, gt;
    typeof k == "string" ? O = Tn(k) : (k.name.includes("addon-essentials") && (gt = k.options), O = Tn(k.name)), _[O] = {
      options: gt,
      version: void 0
    };
  });
  let P = qi(e);
  P && (_.chromatic = {
    version: void 0,
    versionSpecifier: P,
    options: void 0
  }), (await yn(_)).forEach(({ name: k, version: O }) => {
    _[k] = _[k] || {
      name: k,
      version: O
    }, _[k].version = O || void 0;
  });
  let A = Object.keys(_), W = Object.keys(a).filter((k) => k.includes("storybook") && !A.includes(k)).reduce((k, O) => ({
    ...k,
    [O]: { version: void 0 }
  }), {});
  (await yn(W)).forEach(({ name: k, version: O }) => {
    W[k] = W[k] || {
      name: k,
      version: O
    }, W[k].version = O || void 0;
  });
  let Te = !!a["eslint-plugin-storybook"], We = (0, ne.getStorybookInfo)(n);
  try {
    let { previewConfigPath: k } = We;
    if (k) {
      let O = await (0, aa.readConfig)(k), gt = !!(O.getFieldNode(["globals"]) || O.getFieldNode(["globalTypes"]));
      o.preview = { ...o.preview, usesGlobals: gt };
    }
  } catch {
  }
  let ht = await oa(), yt = await Wi((0, ia.dirname)(t));
  return {
    ...o,
    ...w,
    portableStoriesFileCount: ht,
    applicationFileCount: yt,
    storybookVersion: wt,
    storybookVersionSpecifier: We.version,
    language: x,
    storybookPackages: W,
    addons: _,
    hasStorybookEslint: Te
  };
}, "computeStorybookMetadata");
async function fl() {
  let t = await gr(process.cwd());
  return t ? {
    packageJsonPath: t,
    packageJson: await Gn(t) || {}
  } : {
    packageJsonPath: process.cwd(),
    packageJson: {}
  };
}
i(fl, "getPackageJsonDetails");
var ar, In = /* @__PURE__ */ i(async (t) => {
  if (ar)
    return ar;
  let { packageJson: e, packageJsonPath: r } = await fl(), n = (t || (0, ne.getStorybookConfiguration)(
    String(e?.scripts?.storybook || ""),
    "-c",
    "--config-dir"
  )) ?? ".storybook", s = await (0, ne.loadMainConfig)({ configDir: n }).catch(() => {
  });
  return ar = await ca({
    mainConfig: s,
    packageJson: e,
    packageJsonPath: r,
    configDir: n
  }), ar;
}, "getStorybookMetadata");

// src/telemetry/telemetry.ts
var _a = T(require("node:os"), 1), wa = T(ua(), 1);

// ../node_modules/nanoid/index.js
var Sn = require("crypto");

// ../node_modules/nanoid/url-alphabet/index.js
var la = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";

// ../node_modules/nanoid/index.js
var ml = 128, ke, Fe, hl = /* @__PURE__ */ i((t) => {
  !ke || ke.length < t ? (ke = Buffer.allocUnsafe(t * ml), (0, Sn.randomFillSync)(ke), Fe = 0) : Fe + t > ke.length && ((0, Sn.randomFillSync)(
  ke), Fe = 0), Fe += t;
}, "fillPool");
var ft = /* @__PURE__ */ i((t = 21) => {
  hl(t -= 0);
  let e = "";
  for (let r = Fe - t; r < Fe; r++)
    e += la[ke[r] & 63];
  return e;
}, "nanoid");

// src/telemetry/anonymous-id.ts
var fa = require("node:path"), ma = require("storybook/internal/common"), ha = require("child_process");
gi();

// src/telemetry/one-way-hash.ts
var pa = require("crypto");
var dr = /* @__PURE__ */ i((t) => {
  let e = (0, pa.createHash)("sha256");
  return e.update("storybook-telemetry-salt"), e.update(t), e.digest("hex");
}, "oneWayHash");

// src/telemetry/anonymous-id.ts
function yl(t) {
  let n = t.trim().replace(/#.*$/, "").replace(/^.*@/, "").replace(/^.*\/\//, "");
  return (n.endsWith(".git") ? n : `${n}.git`).replace(":", "/");
}
i(yl, "normalizeGitUrl");
function gl(t, e) {
  return `${yl(t)}${an(e)}`;
}
i(gl, "unhashedProjectId");
var ur, ya = /* @__PURE__ */ i(() => {
  if (ur)
    return ur;
  try {
    let t = (0, fa.relative)((0, ma.getProjectRoot)(), process.cwd()), e = (0, ha.execSync)("git config --local --get remote.origin.url", {
      timeout: 1e3,
      stdio: "pipe"
    });
    ur = dr(gl(String(e), t));
  } catch {
  }
  return ur;
}, "getAnonymousProjectId");

// src/telemetry/event-cache.ts
var lr = require("storybook/internal/common");
var En = Promise.resolve(), xl = /* @__PURE__ */ i(async (t, e) => {
  let r = await lr.cache.get("lastEvents") || {};
  r[t] = { body: e, timestamp: Date.now() }, await lr.cache.set("lastEvents", r);
}, "setHelper"), xa = /* @__PURE__ */ i(async (t, e) => (await En, En = xl(t, e), En), "set");
var bl = /* @__PURE__ */ i((t) => {
  let { body: e, timestamp: r } = t;
  return {
    timestamp: r,
    eventType: e?.eventType,
    eventId: e?.eventId,
    sessionId: e?.sessionId
  };
}, "upgradeFields"), vl = ["init", "upgrade"], _l = ["build", "dev", "error"], ga = /* @__PURE__ */ i((t, e) => {
  let r = e.map((n) => t?.[n]).filter(Boolean).sort((n, s) => s.timestamp - n.timestamp);
  return r.length > 0 ? r[0] : void 0;
}, "lastEvent"), ba = /* @__PURE__ */ i(async (t = void 0) => {
  let e = t || await lr.cache.get("lastEvents") || {}, r = ga(e, vl), n = ga(e, _l);
  if (r)
    return !n?.timestamp || r.timestamp > n.timestamp ? bl(r) : void 0;
}, "getPrecedingUpgrade");

// src/telemetry/fetch.ts
var va = global.fetch;

// src/telemetry/session-id.ts
var Cn = require("storybook/internal/common");
var wl = 1e3 * 60 * 60 * 2, mt;
var Pn = /* @__PURE__ */ i(async () => {
  let t = Date.now();
  if (!mt) {
    let e = await Cn.cache.get("session");
    e && e.lastUsed >= t - wl ? mt = e.id : mt = ft();
  }
  return await Cn.cache.set("session", { id: mt, lastUsed: t }), mt;
}, "getSessionId");

// src/telemetry/telemetry.ts
var kl = (0, wa.default)(va), Tl = process.env.STORYBOOK_TELEMETRY_URL || "https://storybook.js.org/event-log", pr = [], ka = /* @__PURE__ */ i(
(t, e) => {
  An[t] = e;
}, "addToGlobalContext"), Il = /* @__PURE__ */ i(() => {
  try {
    let t = _a.platform();
    return t === "win32" ? "Windows" : t === "darwin" ? "macOS" : t === "linux" ? "Linux" : `Other: ${t}`;
  } catch {
    return "Unknown";
  }
}, "getOperatingSystem"), An = {
  inCI: !!process.env.CI,
  isTTY: process.stdout.isTTY,
  platform: Il(),
  nodeVersion: process.versions.node,
  storybookVersion: wt
}, Sl = /* @__PURE__ */ i(async (t, e, r) => {
  let { eventType: n, payload: s, metadata: o, ...a } = t, c = await Pn(), p = ft(), l = { ...a, eventType: n, eventId: p, sessionId: c, metadata: o,
  payload: s, context: e };
  return kl(Tl, {
    method: "post",
    body: JSON.stringify(l),
    headers: { "Content-Type": "application/json" },
    retries: 3,
    retryOn: [503, 504],
    retryDelay: /* @__PURE__ */ i((f) => 2 ** f * (typeof r?.retryDelay == "number" && !Number.isNaN(r?.retryDelay) ? r.retryDelay : 1e3), "\
retryDelay")
  });
}, "prepareRequest");
async function Ta(t, e = { retryDelay: 1e3, immediate: !1 }) {
  let { eventType: r, payload: n, metadata: s, ...o } = t, a = e.stripMetadata ? An : {
    ...An,
    anonymousId: ya()
  }, c;
  try {
    c = Sl(t, a, e), pr.push(c), e.immediate ? await Promise.all(pr) : await c;
    let p = await Pn(), l = ft(), f = { ...o, eventType: r, eventId: l, sessionId: p, metadata: s, payload: n, context: a };
    await xa(r, f);
  } catch {
  } finally {
    pr = pr.filter((p) => p !== c);
  }
}
i(Ta, "sendTelemetry");

// src/telemetry/index.ts
var El = /* @__PURE__ */ i((t) => t.startsWith("example-button--") || t.startsWith("example-header--") || t.startsWith("example-page--"), "i\
sExampleStoryId"), Cl = /* @__PURE__ */ i(async (t, e = {}, r = {}) => {
  t !== "boot" && r.notify !== !1 && await Un();
  let n = {
    eventType: t,
    payload: e
  };
  try {
    r?.stripMetadata || (n.metadata = await In(r?.configDir));
  } catch (s) {
    n.payload.metadataErrorMessage = Ge(s).message, r?.enableCrashReports && (n.payload.metadataError = Ge(s));
  } finally {
    let { error: s } = n.payload;
    s && (n.payload.error = Ge(s)), (!n.payload.error || r?.enableCrashReports) && (process.env?.STORYBOOK_TELEMETRY_DEBUG && (On.logger.info(
    `
[telemetry]`), On.logger.info(JSON.stringify(n, null, 2))), await Ta(n, r));
  }
}, "telemetry");
